--- uds_daemon.c	2015-10-02 16:46:57.252079000 -0700
+++ /home/mtk09519/perforce/ws_14/Pach_CBr/MT7687_HomeKit_DEV/Pach/mcu/build.bach/work/libmDNSResponder/src/mDNSResponder-320.10.80_verified/mDNSShared/uds_daemon.c	2015-10-01 16:04:35.447946000 -0700
@@ -1,6 +1,6 @@
 /* -*- Mode: C; tab-width: 4 -*-
  *
- * Copyright (c) 2003-2013 Apple Computer, Inc. All rights reserved.
+ * Copyright (c) 2003-2006 Apple Computer, Inc. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -54,15 +54,6 @@
 #endif
 #endif
 
-#ifdef LOCAL_PEERPID
-#include <sys/un.h>         // for LOCAL_PEERPID
-#include <sys/socket.h>     // for getsockopt
-#include <sys/proc_info.h>  // for struct proc_bsdshortinfo
-#include <libproc.h>        // for proc_pidinfo()
-#endif //LOCAL_PEERPID
-//upto 16 characters of process name (defined in <sys/proc.h> but we do not want to include that file)
-#define MAXCOMLEN 16
-
 #if APPLE_OSX_mDNSResponder
 #include <WebFilterDNS/WebFilterDNS.h>
 
@@ -84,9 +75,6 @@
 // User IDs for real user accounts start at 501 and count up from there
 #define SystemUID(X) ((X) <= 500)
 
-//#define MAX_ANONYMOUS_DATA      256
-#define MAX_ANONYMOUS_DATA      64
-
 // ***************************************************************************
 #if COMPILER_LIKES_PRAGMA_MARK
 #pragma mark -
@@ -141,21 +129,12 @@
     DNSQuestion q;
 } browser_t;
 
-#ifdef _WIN32
-    typedef unsigned int pid_t;
-    typedef unsigned int socklen_t;
-#endif
-
 struct request_state
 {
     request_state *next;
     request_state *primary;         // If this operation is on a shared socket, pointer to primary
                                     // request_state for the original DNSServiceCreateConnection() operation
     dnssd_sock_t sd;
-    pid_t process_id;               // Client's PID value
-    char  pid_name[MAXCOMLEN];      // Client's process name
-    char uuid[UUID_SIZE];
-    mDNSBool validUUID;
     dnssd_sock_t errsd;
     mDNSu32 uid;
     void * platform_data;
@@ -189,7 +168,6 @@
             mDNSBool ForceMCast;
             domainname regtype;
             browser_t *browsers;
-            const mDNSu8 *AnonData;
         } browser;
         struct
         {
@@ -206,7 +184,6 @@
             mDNSBool autorename;            // Set if this client wants us to automatically rename on conflict
             mDNSBool allowremotequery;      // Respond to unicast queries from outside the local link?
             int num_subtypes;
-            mDNSBool AnonData;
             service_instance *instances;
         } servicereg;
         struct
@@ -218,8 +195,6 @@
             DNSQuestion *q42;
             DNSQuestion q6;
             DNSQuestion *q62;
-            mDNSu8 v4ans;
-            mDNSu8 v6ans;
         } addrinfo;
         struct
         {
@@ -228,7 +203,9 @@
         } pm;
         struct
         {
+#if 0
             DNSServiceFlags flags;
+#endif
             DNSQuestion q_all;
             DNSQuestion q_default;
         } enumeration;
@@ -236,7 +213,6 @@
         {
             DNSQuestion q;
             DNSQuestion *q2;
-            mDNSu8 ans;
         } queryrecord;
         struct
         {
@@ -280,16 +256,6 @@
 
 static dnssd_sock_t listenfd = dnssd_InvalidSocket;
 static request_state *all_requests = NULL;
-#ifdef LOCAL_PEERPID
-struct proc_bsdshortinfo proc;
-#endif //LOCAL_PEERPID
-mDNSlocal void set_peer_pid(request_state *request);
-mDNSlocal void LogMcastClientInfo(request_state *req);
-mDNSlocal void GetMcastClients(request_state *req);
-static mDNSu32 mcount;     // tracks the current active mcast operations for McastLogging
-static mDNSu32 i_mcount;   // sets mcount when McastLogging is enabled(PROF signal is sent)
-static mDNSu32 n_mrecords; // tracks the current active mcast records for McastLogging
-static mDNSu32 n_mquests;  // tracks the current active mcast questions for McastLogging
 
 // Note asymmetry here between registration and browsing.
 // For service registrations we only automatically register in domains that explicitly appear in local configuration data
@@ -315,8 +281,6 @@
 #define PID_FILE "/var/run/mDNSResponder.pid"
 #endif
 
-mDNSlocal char *AnonDataToString(const mDNSu8 *ad, int adlen, char *adstr, int adstrlen);
-
 // ***************************************************************************
 #if COMPILER_LIKES_PRAGMA_MARK
 #pragma mark -
@@ -325,9 +289,8 @@
 
 mDNSlocal void FatalError(char *errmsg)
 {
-    char* ptr = NULL;
     LogMsg("%s: %s", errmsg, dnssd_strerror(dnssd_errno));
-    *ptr = 0;   // On OS X abort() doesn't generate a crash log, but writing to zero does
+	*(long*)0 = 0;	// On OS X abort() doesn't generate a crash log, but writing to zero does
     //FIXED abort();    // On platforms where writing to zero doesn't generate an exception, abort instead
 }
 
@@ -345,136 +308,6 @@
     LogMsg("%s: %d (%s)", errmsg, dnssd_errno, dnssd_strerror(dnssd_errno));
 }
 
-// Throttled version of my_perror: Logs once every 250 msgs
-mDNSlocal void my_throttled_perror(char *err_msg)
-{
-    static int uds_throttle_count = 0;
-    if ((uds_throttle_count++ % 250) == 0) 
-        my_perror(err_msg);
-} 
-
-// LogMcastQuestion/LogMcastQ should be called after the DNSQuestion struct is initialized(especially for q->TargetQID)
-// Hence all calls are made after mDNS_StartQuery()/mDNS_StopQuery()/mDNS_StopBrowse() is called.
-mDNSlocal void LogMcastQuestion(mDNS *const m, const DNSQuestion *const q, request_state *req, q_state status)
-{
-    if (mDNSOpaque16IsZero(q->TargetQID)) // Check for Mcast Query
-    {
-        mDNSBool mflag = mDNSfalse;
-        if (status == q_start)
-        {
-            if (++mcount == 1)
-                mflag = mDNStrue;
-        }
-        else
-        {
-            mcount--;
-        }
-        LogMcast("%s: %##s  (%s) (%s)  Client(%d)[%s]", status ? "+Question" : "-Question", q->qname.c, DNSTypeName(q->qtype), 
-                 q->InterfaceID == mDNSInterface_LocalOnly ? "lo" : q->InterfaceID == mDNSInterface_P2P ? "p2p" : 
-                 q->InterfaceID == mDNSInterface_Any ? "any" : InterfaceNameForID(m, q->InterfaceID), 
-                 req->process_id, req->pid_name);
-        LogMcastStateInfo(m, mflag, mDNSfalse, mDNSfalse);
-    }
-    return;
-}
-
-// LogMcastService/LogMcastS should be called after the AuthRecord struct is initialized
-// Hence all calls are made after mDNS_Register()/ just before mDNS_Deregister()
-mDNSlocal void LogMcastService(mDNS *const m, const AuthRecord *const ar, request_state *req, reg_state status)
-{
-    if (!AuthRecord_uDNS(ar)) // Check for Mcast Service
-    {
-        mDNSBool mflag = mDNSfalse;
-        if (status == reg_start)
-        {
-            if (++mcount == 1)
-                mflag = mDNStrue;
-        }
-        else
-        {
-            mcount--;
-        }
-        LogMcast("%s: %##s  (%s)  (%s)  Client(%d)[%s]", status ? "+Service" : "-Service", ar->resrec.name->c, DNSTypeName(ar->resrec.rrtype),
-                 ar->resrec.InterfaceID == mDNSInterface_LocalOnly ? "lo" : ar->resrec.InterfaceID == mDNSInterface_P2P ? "p2p" : 
-                 ar->resrec.InterfaceID == mDNSInterface_Any ? "all" : InterfaceNameForID(m, ar->resrec.InterfaceID), 
-                 req->process_id, req->pid_name);
-        LogMcastStateInfo(m, mflag, mDNSfalse, mDNSfalse);
-    }
-    return;
-}
-
-// For complete Mcast State Log, pass mDNStrue to mstatelog in LogMcastStateInfo()
-mDNSexport void LogMcastStateInfo(mDNS *const m, mDNSBool mflag, mDNSBool start, mDNSBool mstatelog)
-{
-    if (!mstatelog)
-    {
-        if (!all_requests)
-        {
-            LogMcastNoIdent("<None>");
-        }
-        else
-        {
-            request_state *req, *r;
-            for (req = all_requests; req; req=req->next)
-            {    
-                if (req->primary) // If this is a subbordinate operation, check that the parent is in the list
-                {    
-                    for (r = all_requests; r && r != req; r=r->next) 
-                        if (r == req->primary) 
-                            goto foundpar;
-                }    
-                // For non-subbordinate operations, and subbordinate operations that have lost their parent, write out their info
-                GetMcastClients(req);
-    foundpar:;
-            }
-            LogMcastNoIdent("--- MCAST RECORDS COUNT[%d] MCAST QUESTIONS COUNT[%d] ---", n_mrecords, n_mquests);
-            n_mrecords = n_mquests = 0; // Reset the values
-        }
-    }
-    else
-    {
-        static mDNSu32 i_mpktnum;
-        i_mcount = 0;
-        if (start)
-            mcount = 0;
-        // mcount is initialized to 0 when the PROF signal is sent since mcount could have
-        // wrong value if MulticastLogging is disabled and then re-enabled
-        LogMcastNoIdent("--- START MCAST STATE LOG ---");
-        if (!all_requests)
-        { 
-            mcount = 0;
-            LogMcastNoIdent("<None>");
-        } 
-        else 
-        {    
-            request_state *req, *r;
-            for (req = all_requests; req; req=req->next)
-            {    
-                if (req->primary) // If this is a subbordinate operation, check that the parent is in the list
-                {    
-                    for (r = all_requests; r && r != req; r=r->next) 
-                        if (r == req->primary) 
-                            goto foundparent;
-                    LogMcastNoIdent("%3d: Orphan operation; parent not found in request list", req->sd);
-                }    
-                // For non-subbordinate operations, and subbordinate operations that have lost their parent, write out their info
-                LogMcastClientInfo(req);
-    foundparent:;
-            }
-            if(!mcount) // To initially set mcount
-                mcount = i_mcount;    
-        }
-        if (mcount == 0)
-        {
-            i_mpktnum = m->MPktNum;
-            LogMcastNoIdent("--- MCOUNT[%d]: IMPKTNUM[%d] ---", mcount, i_mpktnum);
-        }
-        if (mflag)
-            LogMcastNoIdent("--- MCOUNT[%d]: CMPKTNUM[%d] - IMPKTNUM[%d] = [%d]PKTS ---", mcount, m->MPktNum, i_mpktnum, (m->MPktNum - i_mpktnum));    
-        LogMcastNoIdent("--- END MCAST STATE LOG ---");
-    }
-}
-
 mDNSlocal void abort_request(request_state *req)
 {
     if (req->terminate == (req_termination_fn) ~0)
@@ -500,6 +333,7 @@
         {
             reply_state *ptr = req->replies;
             req->replies = req->replies->next;
+			//freeL("reply_state (abort)", ptr);
             os_free(ptr);
         }
     }
@@ -521,6 +355,7 @@
     request_state **p = &all_requests;
     abort_request(req);
     while (*p && *p != req) p=&(*p)->next;
+	//if (*p) { *p = req->next; freeL("request_state/AbortUnlinkAndFree", req); }
     if (*p) { *p = req->next; os_free(req); }
     else LogMsg("AbortUnlinkAndFree: ERROR: Attempt to abort operation %p not in list", req);
 }
@@ -694,13 +529,8 @@
         artype = AuthRecordLocalOnly;
     else if (InterfaceID == mDNSInterface_P2P)
         artype = AuthRecordP2P;
-    else if ((InterfaceID == mDNSInterface_Any) && (flags & kDNSServiceFlagsIncludeP2P)
-            && (flags & kDNSServiceFlagsIncludeAWDL))
-        artype = AuthRecordAnyIncludeAWDLandP2P;
     else if ((InterfaceID == mDNSInterface_Any) && (flags & kDNSServiceFlagsIncludeP2P))
         artype = AuthRecordAnyIncludeP2P;
-    else if ((InterfaceID == mDNSInterface_Any) && (flags & kDNSServiceFlagsIncludeAWDL))
-        artype = AuthRecordAnyIncludeAWDL;
     else
         artype = AuthRecordAny;
 
@@ -710,6 +540,7 @@
     if (!MakeDomainNameFromDNSNameString(&rr->namestorage, name))
     {
         LogMsg("ERROR: bad name: %s", name);
+		//freeL("AuthRecord/read_rr_from_ipc_msg", rr);
         os_free(rr);
         return NULL;
     }
@@ -783,27 +614,6 @@
 #pragma mark - external helpers
 #endif
 
-mDNSlocal mDNSBool callExternalHelpers(mDNSInterfaceID InterfaceID, const domainname *const domain, DNSServiceFlags flags)
-{
-#if APPLE_OSX_mDNSResponder
-
-    if (   ((InterfaceID == mDNSInterface_Any) && (flags & (kDNSServiceFlagsIncludeP2P | kDNSServiceFlagsIncludeAWDL)) && IsLocalDomain(domain))
-        || mDNSPlatformInterfaceIsD2D(InterfaceID))
-    {
-        return mDNStrue;
-    }
-    else
-        return mDNSfalse;
-
-#else
-    (void) InterfaceID;
-    (void) domain;
-    (void) flags;
-
-    return mDNSfalse;
-#endif  // APPLE_OSX_mDNSResponder
-}
-
 mDNSlocal void external_start_advertising_helper(service_instance *const instance)
 {
     AuthRecord *st = instance->subtypes;
@@ -816,17 +626,24 @@
         return;
     }
 
+#if APPLE_OSX_mDNSResponder
+	// Update packet filter if p2p interface already exists, otherwise,
+	// if will be updated when we get the KEV_DL_IF_ATTACHED event for
+	// the interface.  Called here since we don't call external_start_advertising_service()
+	// with the SRV record when advertising a service.
+	mDNSInitPacketFilter();
+#endif // APPLE_OSX_mDNSResponder
+
     if (instance->external_advertise) LogMsg("external_start_advertising_helper: external_advertise already set!");
 
     for ( i = 0; i < instance->request->u.servicereg.num_subtypes; i++)
-        external_start_advertising_service(&st[i].resrec, instance->request->flags);
+		external_start_advertising_service(&st[i].resrec);
 
-    external_start_advertising_service(&instance->srs.RR_PTR.resrec, instance->request->flags);
-    external_start_advertising_service(&instance->srs.RR_SRV.resrec, instance->request->flags);
-    external_start_advertising_service(&instance->srs.RR_TXT.resrec, instance->request->flags);
+	external_start_advertising_service(&instance->srs.RR_PTR.resrec);
+	external_start_advertising_service(&instance->srs.RR_TXT.resrec);
 
     for (e = instance->srs.Extras; e; e = e->next)
-        external_start_advertising_service(&e->r.resrec, instance->request->flags);
+		external_start_advertising_service(&e->r.resrec);
 
     instance->external_advertise = mDNStrue;
 }
@@ -842,14 +659,13 @@
     LogInfo("external_stop_advertising_helper: calling external_stop_advertising_service");
 
     for ( i = 0; i < instance->request->u.servicereg.num_subtypes; i++)
-        external_stop_advertising_service(&st[i].resrec, instance->request->flags);
+		external_stop_advertising_service(&st[i].resrec);
 
-    external_stop_advertising_service(&instance->srs.RR_PTR.resrec, instance->request->flags);
-    external_stop_advertising_service(&instance->srs.RR_SRV.resrec, instance->request->flags);
-    external_stop_advertising_service(&instance->srs.RR_TXT.resrec, instance->request->flags);
+	external_stop_advertising_service(&instance->srs.RR_PTR.resrec);
+	external_stop_advertising_service(&instance->srs.RR_TXT.resrec);
 
     for (e = instance->srs.Extras; e; e = e->next)
-        external_stop_advertising_service(&e->r.resrec, instance->request->flags);
+		external_stop_advertising_service(&e->r.resrec);
 
     instance->external_advertise = mDNSfalse;
 }
@@ -870,7 +686,9 @@
     LogInfo("     FreeExtraRR %s", RRDisplayString(m, &rr->resrec));
 
     if (rr->resrec.rdata != &rr->rdatastorage)
+		//freeL("Extra RData", rr->resrec.rdata);
         os_free(rr->resrec.rdata);
+	//freeL("ExtraResourceRecord/FreeExtraRR", extra);
     os_free(extra);
 }
 
@@ -900,18 +718,12 @@
     }
 
     if (srv->srs.RR_TXT.resrec.rdata != &srv->srs.RR_TXT.rdatastorage)
+		//freeL("TXT RData", srv->srs.RR_TXT.resrec.rdata);
         os_free(srv->srs.RR_TXT.resrec.rdata);
 
-    if (srv->subtypes)
-    {
-        os_free(srv->subtypes);
-        srv->subtypes = NULL;
-    }
-    if (srv->srs.AnonData)
-    {
-        os_free((void *)srv->srs.AnonData);
-        srv->srs.AnonData = NULL;
-    }
+	//if (srv->subtypes) { freeL("ServiceSubTypes", srv->subtypes); srv->subtypes = NULL; }
+	if (srv->subtypes) { os_free(srv->subtypes); srv->subtypes = NULL; }
+	//freeL("service_instance", srv);
     os_free(srv);
 }
 
@@ -1005,7 +817,7 @@
             LogMsg("%3d: regservice_callback: %##s is not valid DNS-SD SRV name", instance->request->sd, srs->RR_SRV.resrec.name->c);
         else { append_reply(instance->request, rep); instance->clientnotified = mDNStrue; }
 
-        if (callExternalHelpers(instance->request->u.servicereg.InterfaceID, &instance->domain, instance->request->flags))
+		if (instance->request->u.servicereg.InterfaceID == mDNSInterface_P2P || (!instance->request->u.servicereg.InterfaceID && SameDomainName(&instance->domain, &localdomain) && (instance->request->flags & kDNSServiceFlagsIncludeP2P)))
         {
             LogInfo("regservice_callback: calling external_start_advertising_helper()");
             external_start_advertising_helper(instance);
@@ -1080,7 +892,9 @@
             // If the record has been updated, we need to free the rdata. Everytime we call mDNS_Update, it calls update_callback
             // with the old rdata (so that we can free it) and stores the new rdata in "rr->resrec.rdata". This means, we need
             // to free the latest rdata for which the update_callback was never called with.
+			//if (rr->resrec.rdata != &rr->rdatastorage) freeL("RData/regrecord_callback", rr->resrec.rdata);
             if (rr->resrec.rdata != &rr->rdatastorage) os_free(rr->resrec.rdata);
+			//freeL("AuthRecord/regrecord_callback", rr);
             os_free(rr);
         }
     }
@@ -1111,70 +925,37 @@
 
         if (result)
         {
-            // If this is a callback to a keepalive record, do not free it.
-            if (result == mStatus_BadStateErr)
-            {
-                LogInfo("regrecord_callback: Callback with error code mStatus_BadStateErr - not freeing the record.");
-            }
-            else
-            {
                 // unlink from list, free memory
                 registered_record_entry **ptr = &request->u.reg_recs;
                 while (*ptr && (*ptr) != re) ptr = &(*ptr)->next;
                 if (!*ptr) { LogMsg("regrecord_callback - record not in list!"); return; }
                 *ptr = (*ptr)->next;
+			//freeL("registered_record_entry AuthRecord regrecord_callback", re->rr);
                 os_free(re->rr);
+			//freeL("registered_record_entry regrecord_callback", re);
                 os_free(re);
              }
-        }
         else
         {
             if (re->external_advertise) LogMsg("regrecord_callback: external_advertise already set!");
 
-            if (callExternalHelpers(re->origInterfaceID, &rr->namestorage, request->flags))
+			if (re->origInterfaceID == mDNSInterface_P2P || (!re->origInterfaceID && IsLocalDomain(&rr->namestorage) && (request->flags & kDNSServiceFlagsIncludeP2P)))
             {
                 LogInfo("regrecord_callback: calling external_start_advertising_service");
-                external_start_advertising_service(&rr->resrec, request->flags);
+				external_start_advertising_service(&rr->resrec);
                 re->external_advertise = mDNStrue;
             }
         }
     }
 }
 
-// set_peer_pid() is called after mem is allocated for each new request in NewRequest()
-// This accounts for 2 places (connect_callback, request_callback)
-mDNSlocal void set_peer_pid(request_state *request)
-{
-    pid_t           p    = (pid_t) -1;
-    socklen_t       len  = sizeof(p);
-    request->pid_name[0] = '\0';
-    request->process_id  = -1;
-#ifdef LOCAL_PEERPID  
-    if (request->sd < 0)  
-        return;
-    // to extract the pid value
-    if (getsockopt(request->sd, SOL_LOCAL, LOCAL_PEERPID, &p, &len) != 0)
-        return;
-    // to extract the process name from the pid value
-    if (proc_pidinfo(p, PROC_PIDT_SHORTBSDINFO, 1, &proc, PROC_PIDT_SHORTBSDINFO_SIZE) == 0)
-        return;
-    mDNSPlatformStrCopy(request->pid_name, proc.pbsi_comm);
-    request->process_id = p;
-#else   // !LOCAL_PEERPID
-    len = 0;
-    if (request->sd < 0)
-        return;
-    LogInfo("set_peer_pid: Not Supported on this version of OS");
-#endif  // LOCAL_PEERPID
-}
-
 mDNSlocal void connection_termination(request_state *request)
 {
     // When terminating a shared connection, we need to scan the all_requests list
     // and terminate any subbordinate operations sharing this file descriptor
     request_state **req = &all_requests;
 
-    LogOperation("%3d: DNSServiceCreateConnection STOP PID[%d](%s)", request->sd, request->process_id, request->pid_name);
+	LogOperation("%3d: DNSServiceCreateConnection STOP", request->sd);
 
     while (*req)
     {
@@ -1186,6 +967,7 @@
             if (tmp->replies) LogMsg("connection_termination ERROR How can subordinate req %p %d have replies queued?", tmp, tmp->sd);
             abort_request(tmp);
             *req = tmp->next;
+			//freeL("request_state/connection_termination", tmp);
             os_free(tmp);
         }
         else
@@ -1195,16 +977,16 @@
     while (request->u.reg_recs)
     {
         registered_record_entry *ptr = request->u.reg_recs;
-        LogOperation("%3d: DNSServiceRegisterRecord(%u %s) STOP PID[%d](%s)", request->sd, ptr->key, RRDisplayString(&mDNSStorage, &ptr->rr->resrec), request->process_id, request->pid_name);
+		LogOperation("%3d: DNSServiceRegisterRecord(%u %s) STOP", request->sd, ptr->key, RRDisplayString(&mDNSStorage, &ptr->rr->resrec));
 		request->u.reg_recs = request->u.reg_recs->next;
         ptr->rr->RecordContext = NULL;
         if (ptr->external_advertise)
         {
             ptr->external_advertise = mDNSfalse;
-            external_stop_advertising_service(&ptr->rr->resrec, request->flags);
+			external_stop_advertising_service(&ptr->rr->resrec);
         }
-        LogMcastS(&mDNSStorage, ptr->rr, request, reg_stop);
         mDNS_Deregister(&mDNSStorage, ptr->rr);     // Will free ptr->rr for us
+		//freeL("registered_record_entry/connection_termination", ptr);
         os_free( ptr);
     }
 }
@@ -1223,6 +1005,7 @@
             request_state *tmp = *req;
             abort_request(tmp);
             *req = tmp->next;
+			//freeL("request_state/handle_cancel_request", tmp);
             os_free(tmp);
         }
         else
@@ -1243,14 +1026,14 @@
             rr->resrec.rrclass == kDNSClass_IN && (rr->resrec.rrtype == kDNSType_A || rr->resrec.rrtype == kDNSType_AAAA ||
                                                    rr->resrec.rrtype == kDNSType_CNAME))
         {
+			//freeL("AuthRecord/handle_regrecord_request", rr);
             os_free(rr);
             return (mStatus_BadParamErr);
         }
         // allocate registration entry, link into list
         //re = mallocL("registered_record_entry", sizeof(registered_record_entry));
 		re = os_malloc(sizeof(registered_record_entry));
-        if (!re) 
-            FatalError("ERROR: malloc");
+		if (!re) FatalError("ERROR: malloc");
         re->key                   = request->hdr.reg_index;
         re->rr                    = rr;
         re->regrec_client_context = request->hdr.client_context;
@@ -1260,27 +1043,25 @@
         rr->RecordCallback        = regrecord_callback;
 
         re->origInterfaceID = rr->resrec.InterfaceID;
-        if (rr->resrec.InterfaceID == mDNSInterface_P2P) 
-            rr->resrec.InterfaceID = mDNSInterface_Any;
+		if (rr->resrec.InterfaceID == mDNSInterface_P2P) rr->resrec.InterfaceID = mDNSInterface_Any;	
 #if 0
         if (!AuthorizedDomain(request, rr->resrec.name, AutoRegistrationDomains)) return (mStatus_NoError);
 #endif
         if (rr->resrec.rroriginalttl == 0)
             rr->resrec.rroriginalttl = DefaultTTLforRRType(rr->resrec.rrtype);
 
-        LogOperation("%3d: DNSServiceRegisterRecord(%u %s) START PID[%d](%s)", request->sd, re->key, RRDisplayString(&mDNSStorage, &rr->resrec), 
-                     request->process_id, request->pid_name);
-
+		LogOperation("%3d: DNSServiceRegisterRecord(%u %s) START", request->sd, re->key, RRDisplayString(&mDNSStorage, &rr->resrec));
         err = mDNS_Register(&mDNSStorage, rr);
         if (err)
         {
             LogOperation("%3d: DNSServiceRegisterRecord(%u %s) ERROR (%d)", request->sd, re->key, RRDisplayString(&mDNSStorage, &rr->resrec), err);
+			//freeL("registered_record_entry", re);
             os_free(re);
+			//freeL("registered_record_entry/AuthRecord", rr);
             os_free(rr);
         }
         else
         {
-            LogMcastS(&mDNSStorage, rr, request, reg_start); 
             re->next = request->u.reg_recs;
             request->u.reg_recs = re;
         }
@@ -1292,18 +1073,14 @@
 
 mDNSlocal void regservice_termination_callback(request_state *request)
 {
-    if (!request) 
-    { 
-        LogMsg("regservice_termination_callback context is NULL"); 
-        return; 
-    }
+	if (!request) { LogMsg("regservice_termination_callback context is NULL"); return; }
     while (request->u.servicereg.instances)
     {
         service_instance *p = request->u.servicereg.instances;
         request->u.servicereg.instances = request->u.servicereg.instances->next;
         // only safe to free memory if registration is not valid, i.e. deregister fails (which invalidates p)
-        LogOperation("%3d: DNSServiceRegister(%##s, %u) STOP PID[%d](%s)", request->sd, p->srs.RR_SRV.resrec.name->c, 
-                     mDNSVal16(p->srs.RR_SRV.resrec.rdata->u.srv.port), request->process_id, request->pid_name);
+		LogOperation("%3d: DNSServiceRegister(%##s, %u) STOP",
+			request->sd, p->srs.RR_SRV.resrec.name->c, mDNSVal16(p->srs.RR_SRV.resrec.rdata->u.srv.port));
 
         external_stop_advertising_helper(p);
 
@@ -1313,18 +1090,12 @@
         // We can't clear p->request *after* the calling mDNS_DeregisterService/unlink_and_free_service_instance
         // because by then we might have already freed p
         p->request = NULL;
-        LogMcastS(&mDNSStorage, &p->srs.RR_SRV, request, reg_stop);
-        if (mDNS_DeregisterService(&mDNSStorage, &p->srs))
-        {
-            unlink_and_free_service_instance(p);
+		if (mDNS_DeregisterService(&mDNSStorage, &p->srs)) unlink_and_free_service_instance(p);
             // Don't touch service_instance *p after this -- it's likely to have been freed already
         }
-    }
     if (request->u.servicereg.txtdata)
-    { 
-        os_free(request->u.servicereg.txtdata); 
-        request->u.servicereg.txtdata = NULL; 
-    }
+		//{ freeL("service_info txtdata", request->u.servicereg.txtdata); request->u.servicereg.txtdata = NULL; }
+		{ os_free(request->u.servicereg.txtdata); request->u.servicereg.txtdata = NULL; }
     if (request->u.servicereg.autoname)
     {
         // Clear autoname before calling UpdateDeviceInfoRecord() so it doesn't mistakenly include this in its count of active autoname registrations
@@ -1347,7 +1118,6 @@
 {
     ServiceRecordSet *srs = &instance->srs;
     mStatus result;
-    mDNSu32 coreFlags = 0;  // translate to corresponding mDNSCore flag definitions
     int size = rdlen > sizeof(RDataBody) ? rdlen : sizeof(RDataBody);
     //ExtraResourceRecord *extra = mallocL("ExtraResourceRecord", sizeof(*extra) - sizeof(RDataBody) + size);
 	ExtraResourceRecord *extra = os_malloc(sizeof(*extra) - sizeof(RDataBody) + size);
@@ -1358,28 +1128,17 @@
     extra->r.rdatastorage.MaxRDLength = (mDNSu16) size;
     extra->r.resrec.rdlength = rdlen;
     mDNSPlatformMemCopy(&extra->r.rdatastorage.u.data, rdata, rdlen);
-    // use InterfaceID value from DNSServiceRegister() call that created the original service
-    extra->r.resrec.InterfaceID = request->u.servicereg.InterfaceID;
 
-    if (request->flags & kDNSServiceFlagsIncludeP2P)
-        coreFlags |= coreFlagIncludeP2P;
-    if (request->flags & kDNSServiceFlagsIncludeAWDL)
-        coreFlags |= coreFlagIncludeAWDL;
-    
-    result = mDNS_AddRecordToService(&mDNSStorage, srs, extra, &extra->r.rdatastorage, ttl, coreFlags);
-    if (result) 
-    { 
-        os_free( extra); 
-        return result; 
-    }
-    LogMcastS(&mDNSStorage, &srs->RR_PTR, request, reg_start);
+	result = mDNS_AddRecordToService(&mDNSStorage, srs, extra, &extra->r.rdatastorage, ttl,
+					(request->flags & kDNSServiceFlagsIncludeP2P) ? 1: 0);
+	//if (result) { freeL("ExtraResourceRecord/add_record_to_service", extra); return result; }
+	if (result) { os_free(extra); return result; }
      
     extra->ClientID = request->hdr.reg_index;
-    if (   instance->external_advertise
-           && callExternalHelpers(request->u.servicereg.InterfaceID, &instance->domain, request->flags))
+	if (instance->external_advertise && (instance->request->u.servicereg.InterfaceID == mDNSInterface_P2P || (!instance->request->u.servicereg.InterfaceID && SameDomainName(&instance->domain, &localdomain) && (instance->request->flags & kDNSServiceFlagsIncludeP2P))))
     {
         LogInfo("add_record_to_service: calling external_start_advertising_service");
-        external_start_advertising_service(&extra->r.resrec, request->flags);
+		external_start_advertising_service(&extra->r.resrec);
     }
     return result;
 }
@@ -1439,22 +1198,14 @@
     if (external_advertise)
     {
         ResourceRecord ext = rr->resrec;
-        DNSServiceFlags flags = 0;
-
-        // Since we don't have a copy of the flags value used when the record was registered,
-        // we'll have to derive it from the ARType field.  
-        if (rr->ARType == AuthRecordAnyIncludeP2P)
-            flags |= kDNSServiceFlagsIncludeP2P;
-        else if (rr->ARType == AuthRecordAnyIncludeAWDL)
-            flags |= kDNSServiceFlagsIncludeAWDL;
-
         if (ext.rdlength == oldrdlen && mDNSPlatformMemSame(&ext.rdata->u, &oldrd->u, oldrdlen)) goto exit;
         SetNewRData(&ext, oldrd, oldrdlen);
-        external_stop_advertising_service(&ext, flags);
+		external_stop_advertising_service(&ext);
         LogInfo("update_callback: calling external_start_advertising_service");
-        external_start_advertising_service(&rr->resrec, flags);
+		external_start_advertising_service(&rr->resrec);
     }
 exit:
+	//if (oldrd != &rr->rdatastorage) freeL("RData/update_callback", oldrd);
     if (oldrd != &rr->rdatastorage) os_free(oldrd);
 }
 
@@ -1476,6 +1227,7 @@
     if (external_advertise) rr->UpdateContext = (void *)external_advertise;
 
     result = mDNS_Update(&mDNSStorage, rr, ttl, rdlen, newrd, update_callback);
+	//if (result) { LogMsg("update_record: Error %d for %s", (int)result, ARDisplayString(&mDNSStorage, rr)); freeL("RData/update_record", newrd); }
     if (result) { LogMsg("update_record: Error %d for %s", (int)result, ARDisplayString(&mDNSStorage, rr)); os_free(newrd); }
     return result;
 }
@@ -1528,6 +1280,7 @@
     if (hdr->reg_index == TXT_RECORD_INDEX)
     {
         if (request->u.servicereg.txtdata)
+			//{ freeL("service_info txtdata", request->u.servicereg.txtdata); request->u.servicereg.txtdata = NULL; }
         { os_free(request->u.servicereg.txtdata); request->u.servicereg.txtdata = NULL; }
         if (rdlen > 0)
         {
@@ -1580,16 +1333,18 @@
     e->rr->RecordContext = NULL;
     if (e->external_advertise)
     {
-        external_stop_advertising_service(&e->rr->resrec, request->flags);
+		external_stop_advertising_service(&e->rr->resrec);
         e->external_advertise = mDNSfalse;
     }
-    LogMcastS(&mDNSStorage, e->rr, request, reg_stop);
     err = mDNS_Deregister(&mDNSStorage, e->rr);     // Will free e->rr for us; we're responsible for freeing e
     if (err)
     {
         LogMsg("ERROR: remove_record, mDNS_Deregister: %d", err);
+		//freeL("registered_record_entry AuthRecord remove_record", e->rr);
         os_free(e->rr);
     }
+		
+	//freeL("registered_record_entry remove_record", e);
     os_free(e);
     return err;
 }
@@ -1604,7 +1359,7 @@
         if (ptr->ClientID == request->hdr.reg_index) // found match
         {
             *rrtype = ptr->r.resrec.rrtype;
-            if (serv->external_advertise) external_stop_advertising_service(&ptr->r.resrec, request->flags);
+			if (serv->external_advertise) external_stop_advertising_service(&ptr->r.resrec);
             err = mDNS_RemoveRecordFromService(&mDNSStorage, &serv->srs, ptr, FreeExtraRR, ptr);
             break;
         }
@@ -1647,28 +1402,13 @@
 // If there's a comma followed by another character,
 // FindFirstSubType overwrites the comma with a nul and returns the pointer to the next character.
 // Otherwise, it returns a pointer to the final nul at the end of the string
-mDNSlocal char *FindFirstSubType(char *p, char **AnonData)
+mDNSlocal char *FindFirstSubType(char *p)
 {
     while (*p)
     {
-        if (p[0] == '\\' && p[1])
-        {
-             p += 2;
-        }
-        else if (p[0] == ',' && p[1])
-        {
-            *p++ = 0;
-            return(p);
-        }
-        else if (p[0] == ':' && p[1])
-        {
-            *p++ = 0;
-            *AnonData = p;
-        }
-        else
-        {
-            p++;
-        }
+		if (p[0] == '\\' && p[1]) p += 2;
+		else if (p[0] == ',' && p[1]) { *p++ = 0; return(p); }
+		else p++;
     }
     return(p);
 }
@@ -1696,10 +1436,10 @@
 }
 
 // Returns -1 if illegal subtype found
-mDNSexport mDNSs32 ChopSubTypes(char *regtype, char **AnonData)
+mDNSexport mDNSs32 ChopSubTypes(char *regtype)
 {
     mDNSs32 NumSubTypes = 0;
-    char *stp = FindFirstSubType(regtype, AnonData);
+	char *stp = FindFirstSubType(regtype);
     while (stp && *stp)                 // If we found a comma...
     {
         if (*stp == ',') return(-1);
@@ -1710,43 +1450,9 @@
     return(NumSubTypes);
 }
 
-mDNSexport AuthRecord *AllocateSubTypes(mDNSs32 NumSubTypes, char *p, char **AnonData)
+mDNSexport AuthRecord *AllocateSubTypes(mDNSs32 NumSubTypes, char *p)
 {
     AuthRecord *st = mDNSNULL;
-    // 
-    // "p" is pointing at the regtype e.g., _http._tcp followed by ":<AnonData>" indicated
-    // by AnonData being non-NULL which is in turn follwed by ",<SubTypes>" indicated by
-    // NumSubTypes being non-zero. We need to skip the initial regtype to get to the actual
-    // data that we want. When we come here, ChopSubTypes has null terminated like this e.g.,
-    //
-    // _http._tcp<NULL><AnonData><NULL><SubType1><NULL><SubType2><NULL> etc.
-    //
-    // 1. If we have Anonymous data and subtypes, skip the regtype (e.g., "_http._tcp")
-    //    to get the AnonData and then skip the AnonData to get to the SubType.
-    //
-    // 2. If we have only SubTypes, skip the regtype to get to the SubType data.
-    //
-    // 3. If we have only AnonData, skip the regtype to get to the AnonData.
-    //
-    // 4. If we don't have AnonData or NumStypes, it is a noop.
-    //
-    if (AnonData)
-    {
-        int len;
-
-        // Skip the regtype
-        while (*p) p++;
-        p++;
-
-        len = strlen(p) + 1;
-        //*AnonData = mallocL("Anonymous", len);
-        *AnonData = os_malloc(len);
-        if (!(*AnonData))
-        {
-           return (mDNSNULL);
-        }
-        mDNSPlatformMemCopy(*AnonData, p, len);
-    }
     if (NumSubTypes)
     {
         mDNSs32 i;
@@ -1756,21 +1462,13 @@
         for (i = 0; i < NumSubTypes; i++)
         {
             mDNS_SetupResourceRecord(&st[i], mDNSNULL, mDNSInterface_Any, kDNSQType_ANY, kStandardTTL, 0, AuthRecordAny, mDNSNULL, mDNSNULL);
-            // First time through we skip the regtype or AnonData. Subsequently, the
-            // previous subtype.
             while (*p) p++;
             p++;
             if (!MakeDomainNameFromDNSNameString(&st[i].namestorage, p))
-            {
-                os_free(st);
-                if (*AnonData)
-                    os_free(*AnonData);
-                return(mDNSNULL);
-            }
+				//{ freeL("ServiceSubTypes", st); return(mDNSNULL); }
+				{ os_free(st); return(mDNSNULL); }
         }
     }
-    // If NumSubTypes is zero and AnonData is non-NULL, we still return NULL but AnonData has been
-    // initialized. The caller knows how to handle this.
     return(st);
 }
 
@@ -1781,20 +1479,19 @@
     const mDNSBool DomainIsLocal = SameDomainName(domain, &localdomain);
     mStatus result;
     mDNSInterfaceID interfaceID = request->u.servicereg.InterfaceID;
-    mDNSu32 coreFlags = 0;
+	mDNSu32 regFlags = 0;
 
-    if (request->flags & kDNSServiceFlagsIncludeP2P)
-        coreFlags |= coreFlagIncludeP2P;
-    if (request->flags & kDNSServiceFlagsIncludeAWDL)
-        coreFlags |= coreFlagIncludeAWDL;
-
-    // Client guarantees that record names are unique, so we can skip sending out initial
-    // probe messages.  Standard name conflict resolution is still done if a conflict is discovered.
-    if (request->flags & kDNSServiceFlagsKnownUnique)
-        coreFlags |= coreFlagKnownUnique;
+	if (interfaceID == mDNSInterface_P2P)
+		{
+		interfaceID = mDNSInterface_Any;
+		regFlags |= regFlagIncludeP2P;
+		}
+	else if (request->flags & kDNSServiceFlagsIncludeP2P)
+		regFlags |= regFlagIncludeP2P;
 
-    if (request->flags & kDNSServiceFlagsWakeOnlyService)
-        coreFlags |= coreFlagWakeOnly;
+	// client guarantees that record names are unique
+	if (request->flags & kDNSServiceFlagsForce)
+		regFlags |= regFlagKnownUnique;
 
     // If the client specified an interface, but no domain, then we honor the specified interface for the "local" (mDNS)
     // registration but for the wide-area registrations we don't (currently) have any concept of a wide-area unicast
@@ -1813,37 +1510,33 @@
         }
     }
 
+	if (mDNSStorage.KnownBugs & mDNS_KnownBug_LimitedIPv6)
+		{
+		// Special-case hack: On Mac OS X 10.6.x and earlier we don't advertise SMB service in AutoTunnel domains,
+		// because AutoTunnel services have to support IPv6, and in Mac OS X 10.6.x the SMB server does not.
+		// <rdar://problem/5482322> BTMM: Don't advertise SMB with BTMM because it doesn't support IPv6
+		if (SameDomainName(&request->u.servicereg.type, (const domainname *) "\x4" "_smb" "\x4" "_tcp"))
+			{
+			DomainAuthInfo *AuthInfo = GetAuthInfoForName(&mDNSStorage, domain);
+			if (AuthInfo && AuthInfo->AutoTunnel) return(kDNSServiceErr_Unsupported);
+			}
+		}
+
     //instance = mallocL("service_instance", sizeof(*instance) + extra_size);
     instance = os_malloc(sizeof(*instance) + extra_size);
     if (!instance) { my_perror("ERROR: malloc"); return mStatus_NoMemoryErr; }
 
     instance->next                          = mDNSNULL;
     instance->request                       = request;
+	instance->subtypes						= AllocateSubTypes(request->u.servicereg.num_subtypes, request->u.servicereg.type_as_string);
     instance->renameonmemfree               = 0;
     instance->clientnotified                = mDNSfalse;
     instance->default_local                 = (request->u.servicereg.default_domain && DomainIsLocal);
     instance->external_advertise            = mDNSfalse;
     AssignDomainName(&instance->domain, domain);
 
-    instance->srs.AnonData = mDNSNULL;
-    if (!request->u.servicereg.AnonData)
-    {
-        instance->subtypes = AllocateSubTypes(request->u.servicereg.num_subtypes, request->u.servicereg.type_as_string, mDNSNULL);
-    }
-    else
-    {
-        char *AnonData = mDNSNULL;
-        instance->subtypes = AllocateSubTypes(request->u.servicereg.num_subtypes, request->u.servicereg.type_as_string, &AnonData);
-        if (AnonData)
-            instance->srs.AnonData = (const mDNSu8 *)AnonData;    
-    }
-
     if (request->u.servicereg.num_subtypes && !instance->subtypes)
-    { 
-        unlink_and_free_service_instance(instance); 
-        instance = NULL; 
-        FatalError("ERROR: malloc"); 
-    }
+		{ unlink_and_free_service_instance(instance); instance = NULL; FatalError("ERROR: malloc"); }
 
     result = mDNS_RegisterService(&mDNSStorage, &instance->srs,
                                   &request->u.servicereg.name, &request->u.servicereg.type, domain,
@@ -1851,14 +1544,13 @@
                                   request->u.servicereg.port,
                                   request->u.servicereg.txtdata, request->u.servicereg.txtlen,
                                   instance->subtypes, request->u.servicereg.num_subtypes,
-                                  interfaceID, regservice_callback, instance, coreFlags);
+		interfaceID, regservice_callback, instance, regFlags);
 
     if (!result)
     {
         *ptr = instance;        // Append this to the end of our request->u.servicereg.instances list
-        LogOperation("%3d: DNSServiceRegister(%##s, %u) ADDED", instance->request->sd, 
-                     instance->srs.RR_SRV.resrec.name->c, mDNSVal16(request->u.servicereg.port));
-        LogMcastS(&mDNSStorage, &instance->srs.RR_SRV, request, reg_start);
+		LogOperation("%3d: DNSServiceRegister(%##s, %u) ADDED",
+			instance->request->sd, instance->srs.RR_SRV.resrec.name->c, mDNSVal16(request->u.servicereg.port));
     }
     else
     {
@@ -1933,79 +1625,18 @@
     }
 }
 
-// Don't allow normal and anonymous registration to coexist.
-mDNSlocal mDNSBool CheckForMixedRegistrations(domainname *regtype, domainname *domain, mDNSBool AnonData)
-{
-    request_state *request;
-
-    // We only care about local domains where the anonymous extension is
-    // implemented.
-    if (!SameDomainName(domain, (const domainname *) "\x5" "local"))
-    {
-        return mDNStrue;
-    }
-
-    for (request = all_requests; request; request = request->next)
-    {
-        service_instance *ptr;
-
-        if (request->terminate != regservice_termination_callback) continue;
-        for (ptr = request->u.servicereg.instances; ptr ; ptr = ptr->next)
-        {
-            if (!SameDomainName(&ptr->domain, (const domainname *)"\x5" "local") ||
-                !SameDomainName(&request->u.servicereg.type, regtype))
-            {
-                continue;
-            }
-
-            // If we are about to register a anonymous registraion, we dont't want to
-            // allow the regular ones and vice versa.
-            if (AnonData)
-            {
-                if (!ptr->srs.AnonData)
-                {
-                    LogMsg("CheckForMixedRegistrations: Normal registration already exists for %##s", regtype->c);
-                    return mDNSfalse;
-                }
-            }
-            else
-            {
-                // Allow multiple regular registrations
-                if (ptr->srs.AnonData)
-                {
-                    LogMsg("CheckForMixedRegistrations: Anonymous registration already exists for %##s", regtype->c);
-                    return mDNSfalse;
-                }
-            }
-        }
-    }
-    return mDNStrue;
-}
-
 mDNSlocal mStatus handle_regservice_request(request_state *request)
 {
     //char name[256]; // Lots of spare space for extra-long names that we'll auto-truncate down to 63 bytes
-    char name[64]; // Lots of spare space for extra-long names that we'll auto-truncate down to 63 bytes
+	char name [64];
     char domain[MAX_ESCAPED_DOMAIN_NAME], host[MAX_ESCAPED_DOMAIN_NAME];
     char type_as_string[MAX_ESCAPED_DOMAIN_NAME];
     domainname d, srv;
     mStatus err;
-    char *AnonData = mDNSNULL;
 
     DNSServiceFlags flags = get_flags(&request->msgptr, request->msgend);
     mDNSu32 interfaceIndex = get_uint32(&request->msgptr, request->msgend);
-    mDNSInterfaceID InterfaceID;
-
-    // Map kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny with the 
-    // kDNSServiceFlagsIncludeP2P flag set.
-    if (interfaceIndex == kDNSServiceInterfaceIndexP2P)
-    {
-        LogOperation("handle_regservice_request: mapping kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny + kDNSServiceFlagsIncludeP2P");
-        flags |= kDNSServiceFlagsIncludeP2P;
-        interfaceIndex = kDNSServiceInterfaceIndexAny;
-    }
-
-    InterfaceID = mDNSPlatformInterfaceIDfromInterfaceIndex(&mDNSStorage, interfaceIndex);
+	mDNSInterfaceID InterfaceID = mDNSPlatformInterfaceIDfromInterfaceIndex(&mDNSStorage, interfaceIndex);
     if (interfaceIndex && !InterfaceID)
     { LogMsg("ERROR: handle_regservice_request - Couldn't find interfaceIndex %d", interfaceIndex); return(mStatus_BadParamErr); }
 
@@ -2041,26 +1672,9 @@
     if (!request->msgptr) { LogMsg("%3d: DNSServiceRegister(unreadable parameters)", request->sd); return(mStatus_BadParamErr); }
 
     // Check for sub-types after the service type
-    request->u.servicereg.num_subtypes = ChopSubTypes(request->u.servicereg.type_as_string, &AnonData);    // Note: Modifies regtype string to remove trailing subtypes
+	request->u.servicereg.num_subtypes = ChopSubTypes(request->u.servicereg.type_as_string);	// Note: Modifies regtype string to remove trailing subtypes
     if (request->u.servicereg.num_subtypes < 0)
-    {
-        LogMsg("ERROR: handle_regservice_request - ChopSubTypes failed %s", request->u.servicereg.type_as_string);
-        return(mStatus_BadParamErr);
-    }
-    if (AnonData)
-    {
-        int AnonDataLen = strlen(AnonData);
-        if (AnonDataLen > MAX_ANONYMOUS_DATA)
-        {
-            LogMsg("ERROR: handle_regservice_request: AnonDataLen %d", AnonDataLen);
-            return(mStatus_BadParamErr);
-        }
-        request->u.servicereg.AnonData = mDNStrue;
-    }
-    else
-    {
-        request->u.servicereg.AnonData = mDNSfalse;
-    }
+		{ LogMsg("ERROR: handle_regservice_request - ChopSubTypes failed %s", request->u.servicereg.type_as_string); return(mStatus_BadParamErr); }
 
     // Don't try to construct "domainname t" until *after* ChopSubTypes has worked its magic
     if (!*request->u.servicereg.type_as_string || !MakeDomainNameFromDNSNameString(&request->u.servicereg.type, request->u.servicereg.type_as_string))
@@ -2096,12 +1710,6 @@
         MakeDomainNameFromDNSNameString(&d, "local.");
     }
 
-    // We don't allow the anonymous and the regular ones to coexist
-    if (!CheckForMixedRegistrations(&request->u.servicereg.type, &d, request->u.servicereg.AnonData))
-    {
-        return(mStatus_BadParamErr);
-    }
-
     if (!ConstructServiceName(&srv, &request->u.servicereg.name, &request->u.servicereg.type, &d))
     {
         LogMsg("ERROR: handle_regservice_request - Couldn't ConstructServiceName from, “%#s” “%##s” “%##s”",
@@ -2120,13 +1728,12 @@
     {
         int count = CountExistingRegistrations(&srv, request->u.servicereg.port);
         if (count)
-            LogMsg("Client application[%d](%s) registered %d identical instances of service %##s port %u.", request->process_id,
-                   request->pid_name, count+1, srv.c, mDNSVal16(request->u.servicereg.port));
+			LogMsg("Client application registered %d identical instances of service %##s port %u.",
+				count+1, srv.c, mDNSVal16(request->u.servicereg.port));
     }
 
-    LogOperation("%3d: DNSServiceRegister(%X, %d, \"%s\", \"%s\", \"%s\", \"%s\", %u) START PID[%d](%s)",
-    	         request->sd, flags, interfaceIndex, name, request->u.servicereg.type_as_string, domain, host, 
-                 mDNSVal16(request->u.servicereg.port), request->process_id, request->pid_name);
+	LogOperation("%3d: DNSServiceRegister(%X, %d, \"%s\", \"%s\", \"%s\", \"%s\", %u) START",
+		request->sd, flags, interfaceIndex, name, request->u.servicereg.type_as_string, domain, host, mDNSVal16(request->u.servicereg.port));
 
     // We need to unconditionally set request->terminate, because even if we didn't successfully
     // start any registrations right now, subsequent configuration changes may cause successful
@@ -2166,7 +1773,7 @@
 
 mDNSlocal void FoundInstance(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)
 {
-    DNSServiceFlags flags = AddRecord ? kDNSServiceFlagsAdd : 0;
+	const DNSServiceFlags flags = AddRecord ? kDNSServiceFlagsAdd : 0;
     request_state *req = question->QuestionContext;
     reply_state *rep;
     (void)m; // Unused
@@ -2174,11 +1781,6 @@
     if (answer->rrtype != kDNSType_PTR)
     { LogMsg("%3d: FoundInstance: Should not be called with rrtype %d (not a PTR record)", req->sd, answer->rrtype); return; }
 
-    if (mDNSOpaque16IsZero(question->TargetQID) && (question->BrowseThreshold > 0) && (question->CurrentAnswers >= question->BrowseThreshold))
-    {
-        flags |= kDNSServiceFlagsThresholdReached;
-    }
-
     if (GenerateNTDResponse(&answer->rdata->u.name, answer->InterfaceID, req, &rep, browse_reply_op, flags, mStatus_NoError) != mStatus_NoError)
     {
         if (SameDomainName(&req->u.browser.regtype, (const domainname*)"\x09_services\x07_dns-sd\x04_udp"))
@@ -2218,26 +1820,25 @@
     b = os_malloc(sizeof(*b));
     if (!b) return mStatus_NoMemoryErr;
     AssignDomainName(&b->domain, d);
-    err = mDNS_StartBrowse(&mDNSStorage, &b->q, &info->u.browser.regtype, d, info->u.browser.AnonData, info->u.browser.interface_id, info->flags, 
-                            info->u.browser.ForceMCast, (info->flags & kDNSServiceFlagsBackgroundTrafficClass) != 0, FoundInstance, info);
+	err = mDNS_StartBrowse(&mDNSStorage, &b->q,
+		&info->u.browser.regtype, d, info->u.browser.interface_id, info->u.browser.ForceMCast, FoundInstance, info);
     if (err)
     {
         LogMsg("mDNS_StartBrowse returned %d for type %##s domain %##s", err, info->u.browser.regtype.c, d->c);
+		//freeL("browser_t/add_domain_to_browser", b);
         os_free(b);
     }
     else
     {
         b->next = info->u.browser.browsers;
         info->u.browser.browsers = b;
-        LogOperation("%3d: DNSServiceBrowse(%##s) START PID[%d](%s)", info->sd, b->q.qname.c, info->process_id, 
-                     info->pid_name);
-        LogMcastQ(&mDNSStorage, &b->q, info, q_start);
-        if (callExternalHelpers(info->u.browser.interface_id, &b->domain, info->flags))
+		LogOperation("%3d: DNSServiceBrowse(%##s) START", info->sd, b->q.qname.c);
+		if (info->u.browser.interface_id == mDNSInterface_P2P || (!info->u.browser.interface_id && SameDomainName(&b->domain, &localdomain) && (info->flags & kDNSServiceFlagsIncludeP2P)))
         {
             domainname tmp;
             ConstructServiceName(&tmp, NULL, &info->u.browser.regtype, &b->domain);
             LogInfo("add_domain_to_browser: calling external_start_browsing_for_service()");
-            external_start_browsing_for_service(info->u.browser.interface_id, &tmp, kDNSType_PTR, info->flags);
+			external_start_browsing_for_service(&mDNSStorage, &tmp, kDNSType_PTR);
         }
     }
     return err;
@@ -2245,30 +1846,22 @@
 
 mDNSlocal void browse_termination_callback(request_state *info)
 {
-    if (info->u.browser.default_domain)
-    {
-        // Stop the domain enumeration queries to discover the WAB legacy browse domains
-        LogInfo("%3d: DNSServiceBrowse Cancel WAB PID[%d](%s)", info->sd, info->process_id, info->pid_name);
-        uDNS_StopWABQueries(&mDNSStorage, UDNS_WAB_LBROWSE_QUERY);
-    }
-    if (info->u.browser.AnonData)
-        os_free((void *)info->u.browser.AnonData);
     while (info->u.browser.browsers)
     {
         browser_t *ptr = info->u.browser.browsers;
 
-        if (callExternalHelpers(info->u.browser.interface_id, &ptr->domain, info->flags))
+		if (info->u.browser.interface_id == mDNSInterface_P2P || (!info->u.browser.interface_id && SameDomainName(&ptr->domain, &localdomain) && (info->flags & kDNSServiceFlagsIncludeP2P)))
         {
             domainname tmp;
             ConstructServiceName(&tmp, NULL, &info->u.browser.regtype, &ptr->domain);
             LogInfo("browse_termination_callback: calling external_stop_browsing_for_service()");
-            external_stop_browsing_for_service(info->u.browser.interface_id, &tmp, kDNSType_PTR, info->flags);
+			external_stop_browsing_for_service(&mDNSStorage, &tmp, kDNSType_PTR);
         }
 
         info->u.browser.browsers = ptr->next;
-        LogOperation("%3d: DNSServiceBrowse(%##s) STOP PID[%d](%s)", info->sd, ptr->q.qname.c, info->process_id, info->pid_name);
+		LogOperation("%3d: DNSServiceBrowse(%##s) STOP", info->sd, ptr->q.qname.c);
         mDNS_StopBrowse(&mDNSStorage, &ptr->q);  // no need to error-check result
-        LogMcastQ(&mDNSStorage, &ptr->q, info, q_stop);         
+		//freeL("browser_t/browse_termination_callback", ptr);
         os_free(ptr);
     }
 }
@@ -2311,6 +1904,7 @@
                         browser_t *rem = *ptr;
                         *ptr = (*ptr)->next;
                         mDNS_StopQueryWithRemoves(&mDNSStorage, &rem->q);
+						//freeL("browser_t/udsserver_automatic_browse_domain_changed", rem);
                         os_free(rem);
                     }
                 }
@@ -2438,8 +2032,6 @@
     }
 }
 
-#if APPLE_OSX_mDNSResponder
-
 mDNSlocal void UpdateDeviceInfoRecord(mDNS *const m)
 {
     int num_autoname = 0;
@@ -2460,19 +2052,17 @@
     if (m->DeviceInfo.resrec.RecordType == kDNSRecordTypeUnregistered)
         if (num_autoname > 0)
         {
+			mDNSu8 len = m->HIHardware.c[0] < 255 - 6 ? m->HIHardware.c[0] : 255 - 6;
             mDNS_SetupResourceRecord(&m->DeviceInfo, mDNSNULL, mDNSNULL, kDNSType_TXT, kStandardTTL, kDNSRecordTypeAdvisory, AuthRecordAny, mDNSNULL, mDNSNULL);
             ConstructServiceName(&m->DeviceInfo.namestorage, &m->nicelabel, &DeviceInfoName, &localdomain);
-            m->DeviceInfo.resrec.rdlength = initializeDeviceInfoTXT(m, m->DeviceInfo.resrec.rdata->u.data);
+			mDNSPlatformMemCopy(m->DeviceInfo.resrec.rdata->u.data + 1, "model=", 6);
+			mDNSPlatformMemCopy(m->DeviceInfo.resrec.rdata->u.data + 7, m->HIHardware.c + 1, len);
+			m->DeviceInfo.resrec.rdata->u.data[0] = 6 + len;	// "model=" plus the device string
+			m->DeviceInfo.resrec.rdlength         = 7 + len;	// One extra for the length byte at the start of the string
             LogOperation("UpdateDeviceInfoRecord   Register %##s", m->DeviceInfo.resrec.name);
             mDNS_Register(m, &m->DeviceInfo);
         }
 }
-#else   // APPLE_OSX_mDNSResponder
-mDNSlocal void UpdateDeviceInfoRecord(mDNS *const m)
-{
-    (void)m; // unused
-}
-#endif  // APPLE_OSX_mDNSResponder
 
 mDNSexport void udsserver_handle_configchange(mDNS *const m)
 {
@@ -2502,7 +2092,7 @@
 
     // Let the platform layer get the current DNS information
     mDNS_Lock(m);
-    mDNSPlatformSetDNSConfig(m, mDNSfalse, mDNSfalse, mDNSNULL, &RegDomains, &BrowseDomains, mDNSfalse);
+	mDNSPlatformSetDNSConfig(m, mDNSfalse, mDNSfalse, mDNSNULL, &RegDomains, &BrowseDomains);
     mDNS_Unlock(m);
 
     // Any automatic registration domains are also implicitly automatic browsing domains
@@ -2576,9 +2166,7 @@
     char regtype[MAX_ESCAPED_DOMAIN_NAME], domain[MAX_ESCAPED_DOMAIN_NAME];
     domainname typedn, d, temp;
     mDNSs32 NumSubTypes;
-    char *AnonData = mDNSNULL;
     mStatus err = mStatus_NoError;
-    int AnonDataLen;
 
     DNSServiceFlags flags = get_flags(&request->msgptr, request->msgend);
     mDNSu32 interfaceIndex = get_uint32(&request->msgptr, request->msgend);
@@ -2590,28 +2178,13 @@
 
     if (!request->msgptr) { LogMsg("%3d: DNSServiceBrowse(unreadable parameters)", request->sd); return(mStatus_BadParamErr); }
 
+	if (domain[0] == '\0') uDNS_SetupSearchDomains(&mDNSStorage, UDNS_START_WAB_QUERY);
+
     request->flags = flags;
     typedn.c[0] = 0;
-    NumSubTypes = ChopSubTypes(regtype, &AnonData);    // Note: Modifies regtype string to remove trailing subtypes
-    if (NumSubTypes < 0 || NumSubTypes > 1)
-        return(mStatus_BadParamErr);
-    AnonDataLen = 0;
-    if (AnonData)
-    {
-        AnonDataLen = strlen(AnonData);
-        if (AnonDataLen > MAX_ANONYMOUS_DATA)
-        {
-            LogMsg("handle_browse_request: AnonDataLen %d", AnonDataLen);
-            return(mStatus_BadParamErr);
-        }
-        // Account for the null byte
-        AnonDataLen += 1;
-    }
-    if (NumSubTypes == 1)
-    {
-        if (!AppendDNSNameString(&typedn, regtype + strlen(regtype) + 1 + AnonDataLen))
-            return(mStatus_BadParamErr);
-    }
+	NumSubTypes = ChopSubTypes(regtype);	// Note: Modifies regtype string to remove trailing subtypes
+	if (NumSubTypes < 0 || NumSubTypes > 1) return(mStatus_BadParamErr);
+	if (NumSubTypes == 1 && !AppendDNSNameString(&typedn, regtype + strlen(regtype) + 1)) return(mStatus_BadParamErr);
 
     if (!regtype[0] || !AppendDNSNameString(&typedn, regtype)) return(mStatus_BadParamErr);
 
@@ -2626,26 +2199,9 @@
     request->u.browser.default_domain = !domain[0];
     request->u.browser.browsers = NULL;
 
-    LogOperation("%3d: DNSServiceBrowse(%X, %d, \"%##s\", \"%s\") START PID[%d](%s)", 
-    request->sd, request->flags, interfaceIndex, request->u.browser.regtype.c, domain, request->process_id, request->pid_name);
+	LogOperation("%3d: DNSServiceBrowse(%X, %d, \"%##s\", \"%s\") START", 
+			request->sd, request->flags, interfaceIndex, request->u.browser.regtype.c, domain);
 
-    if (request->u.browser.default_domain)
-    {
-        // Start the domain enumeration queries to discover the WAB browse domains
-        LogInfo("%3d: DNSServiceBrowse Start WAB PID[%d](%s)", request->sd, request->process_id, request->pid_name);
-        uDNS_StartWABQueries(&mDNSStorage, UDNS_WAB_LBROWSE_QUERY);
-    }
-    request->u.browser.AnonData = mDNSNULL;
-    if (AnonData)
-    {
-        int len = strlen(AnonData) + 1;
-        //request->u.browser.AnonData = mallocL("Anonymous", len);
-        request->u.browser.AnonData = os_malloc(len);
-        if (!request->u.browser.AnonData)
-            return mStatus_NoMemoryErr;
-        else
-            mDNSPlatformMemCopy((void *)request->u.browser.AnonData, AnonData, len);
-    }
     // We need to unconditionally set request->terminate, because even if we didn't successfully
     // start any browses right now, subsequent configuration changes may cause successful
     // browses to be added, and we'll need to cancel them before freeing this memory.
@@ -2655,6 +2211,9 @@
     {
         if (!MakeDomainNameFromDNSNameString(&d, domain)) return(mStatus_BadParamErr);
         err = add_domain_to_browser(request, &d);
+#if 0
+		err = AuthorizedDomain(request, &d, AutoBrowseDomains) ? add_domain_to_browser(request, &d) : mStatus_NoError;
+#endif
     }
     else
     {
@@ -2737,12 +2296,10 @@
 
 mDNSlocal void resolve_termination_callback(request_state *request)
 {
-    LogOperation("%3d: DNSServiceResolve(%##s) STOP PID[%d](%s)", request->sd, request->u.resolve.qtxt.qname.c, request->process_id, request->pid_name);
+	LogOperation("%3d: DNSServiceResolve(%##s) STOP", request->sd, request->u.resolve.qtxt.qname.c);
     mDNS_StopQuery(&mDNSStorage, &request->u.resolve.qtxt);
     mDNS_StopQuery(&mDNSStorage, &request->u.resolve.qsrv);
-    LogMcastQ(&mDNSStorage, &request->u.resolve.qsrv, request, q_stop);
-    if (request->u.resolve.external_advertise) 
-        external_stop_resolving_service(request->u.resolve.qsrv.InterfaceID, &request->u.resolve.qsrv.qname, request->flags);
+	if (request->u.resolve.external_advertise) external_stop_resolving_service(&request->u.resolve.qsrv.qname);
 }
 
 mDNSlocal mStatus handle_resolve_request(request_state *request)
@@ -2756,15 +2313,11 @@
     DNSServiceFlags flags = get_flags(&request->msgptr, request->msgend);
     mDNSu32 interfaceIndex = get_uint32(&request->msgptr, request->msgend);
     mDNSInterfaceID InterfaceID;
+	mDNSBool wasP2P = (interfaceIndex == kDNSServiceInterfaceIndexP2P);
 
-    // Map kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny with the kDNSServiceFlagsIncludeP2P
-    // flag set so that the resolve will run over P2P interfaces that are not yet created.
-    if (interfaceIndex == kDNSServiceInterfaceIndexP2P)
-    {
-        LogOperation("handle_resolve_request: mapping kDNSServiceInterfaceIndexP2P to kDNSServiceInterfaceIndexAny + kDNSServiceFlagsIncludeP2P");
-        flags |= kDNSServiceFlagsIncludeP2P;
-        interfaceIndex = kDNSServiceInterfaceIndexAny;
-    }
+	
+	request->flags = flags;
+	if (wasP2P) interfaceIndex = kDNSServiceInterfaceIndexAny;
 
     InterfaceID = mDNSPlatformInterfaceIDfromInterfaceIndex(&mDNSStorage, interfaceIndex);
     if (interfaceIndex && !InterfaceID)
@@ -2783,11 +2336,8 @@
 
     mDNSPlatformMemZero(&request->u.resolve, sizeof(request->u.resolve));
 
-    request->flags = flags;
-
     // format questions
     request->u.resolve.qsrv.InterfaceID      = InterfaceID;
-    request->u.resolve.qsrv.flags            = flags;
     request->u.resolve.qsrv.Target           = zeroAddr;
     AssignDomainName(&request->u.resolve.qsrv.qname, &fqdn);
     request->u.resolve.qsrv.qtype            = kDNSType_SRV;
@@ -2802,18 +2352,11 @@
     request->u.resolve.qsrv.RetryWithSearchDomains = mDNSfalse;
     request->u.resolve.qsrv.TimeoutQuestion  = 0;
     request->u.resolve.qsrv.WakeOnResolve    = (flags & kDNSServiceFlagsWakeOnResolve) != 0;
-    request->u.resolve.qsrv.UseBackgroundTrafficClass = (flags & kDNSServiceFlagsBackgroundTrafficClass) != 0;
-    request->u.resolve.qsrv.ValidationRequired = 0;
-    request->u.resolve.qsrv.ValidatingResponse = 0;
-    request->u.resolve.qsrv.ProxyQuestion    = 0;
     request->u.resolve.qsrv.qnameOrig        = mDNSNULL;
-    request->u.resolve.qsrv.AnonInfo         = mDNSNULL;
-    request->u.resolve.qsrv.pid              = request->process_id;
     request->u.resolve.qsrv.QuestionCallback = resolve_result_callback;
     request->u.resolve.qsrv.QuestionContext  = request;
 
     request->u.resolve.qtxt.InterfaceID      = InterfaceID;
-    request->u.resolve.qtxt.flags            = flags;
     request->u.resolve.qtxt.Target           = zeroAddr;
     AssignDomainName(&request->u.resolve.qtxt.qname, &fqdn);
     request->u.resolve.qtxt.qtype            = kDNSType_TXT;
@@ -2828,13 +2371,7 @@
     request->u.resolve.qtxt.RetryWithSearchDomains = mDNSfalse;
     request->u.resolve.qtxt.TimeoutQuestion  = 0;
     request->u.resolve.qtxt.WakeOnResolve    = 0;
-    request->u.resolve.qtxt.UseBackgroundTrafficClass = (flags & kDNSServiceFlagsBackgroundTrafficClass) != 0;
-    request->u.resolve.qtxt.ValidationRequired = 0;
-    request->u.resolve.qtxt.ValidatingResponse = 0;
-    request->u.resolve.qtxt.ProxyQuestion    = 0;
     request->u.resolve.qtxt.qnameOrig        = mDNSNULL;
-    request->u.resolve.qtxt.AnonInfo         = mDNSNULL;
-    request->u.resolve.qtxt.pid              = request->process_id;
     request->u.resolve.qtxt.QuestionCallback = resolve_result_callback;
     request->u.resolve.qtxt.QuestionContext  = request;
 
@@ -2847,26 +2384,21 @@
 #endif
 
     // ask the questions
-    LogOperation("%3d: DNSServiceResolve(%X %d %##s) START PID[%d](%s)", request->sd, flags, interfaceIndex, 
-    	         request->u.resolve.qsrv.qname.c, request->process_id, request->pid_name);
+	LogOperation("%3d: DNSServiceResolve(%##s) START", request->sd, request->u.resolve.qsrv.qname.c);
     err = mDNS_StartQuery(&mDNSStorage, &request->u.resolve.qsrv);
-    
     if (!err)
     {
         err = mDNS_StartQuery(&mDNSStorage, &request->u.resolve.qtxt);
-        if (err)
-        { 
-            mDNS_StopQuery(&mDNSStorage, &request->u.resolve.qsrv);
-        }
+		if (err) mDNS_StopQuery(&mDNSStorage, &request->u.resolve.qsrv);
         else
         {
             request->terminate = resolve_termination_callback;
-            LogMcastQ(&mDNSStorage, &request->u.resolve.qsrv, request, q_start);
-            if (callExternalHelpers(InterfaceID, &fqdn, flags))
+			// If the user explicitly passed in P2P, we don't restrict the domain in which we resolve.
+			if (wasP2P || (!InterfaceID && IsLocalDomain(&fqdn) && (request->flags & kDNSServiceFlagsIncludeP2P)))
             {
                 request->u.resolve.external_advertise    = mDNStrue;
                 LogInfo("handle_resolve_request: calling external_start_resolving_service()");
-                external_start_resolving_service(InterfaceID, &fqdn, flags);
+				external_start_resolving_service(&fqdn);
             }
         }
     }
@@ -2963,74 +2495,18 @@
 
 #if APPLE_OSX_mDNSResponder
 
-mDNSlocal mDNSBool DomainInSearchList(const domainname *domain, mDNSBool excludeLocal)
+mDNSlocal mDNSBool DomainInSearchList(domainname *domain)
 {
     const SearchListElem *s;
-    int qcount, scount;
-
-    qcount = CountLabels(domain);
     for (s=SearchList; s; s=s->next)
-    {
-        if (excludeLocal && SameDomainName(&s->domain, &localdomain))
-            continue;
-        scount = CountLabels(&s->domain);
-        if (qcount >= scount)
-        {
-            // Note: When qcount == scount, we do a complete match of the domain
-            // which is expected by the callers.
-            const domainname *d = SkipLeadingLabels(domain, (qcount - scount));
-            if (SameDomainName(&s->domain, d))
-            {
-                return mDNStrue;
-            }
-        }
-    }
+		if (SameDomainName(&s->domain, domain)) return mDNStrue;
     return mDNSfalse;
 }
 
-// The caller already checks that this is a dotlocal question.
-mDNSlocal mDNSBool ShouldDeliverNegativeResponse(mDNS *const m, DNSQuestion *question)
-{
-    mDNSu16 qtype;
-
-    // If the question matches the search domain exactly or the search domain is a
-    // subdomain of the question, it is most likely a valid unicast domain and hence
-    // don't suppress negative responses.
-    //
-    // If the user has configured ".local" as a search domain, we don't want
-    // to deliver a negative response for names ending in ".local" as that would
-    // prevent bonjour discovery. Passing mDNStrue for the last argument excludes
-    // ".local" search domains.
-    if (DomainInSearchList(&question->qname, mDNStrue))
-    {
-        LogOperation("ShouldDeliverNegativeResponse: Question %##s (%s) in SearchList", question->qname.c, DNSTypeName(question->qtype));
-        return mDNStrue;
-    }
-
-    // Deliver negative response for A/AAAA if there was a positive response for AAAA/A respectively.
-    if (question->qtype != kDNSType_A && question->qtype != kDNSType_AAAA)
-    {
-        LogOperation("ShouldDeliverNegativeResponse: Question %##s (%s) not answering local question with negative unicast response",
-            question->qname.c, DNSTypeName(question->qtype));
-        return mDNSfalse;
-    }
-    qtype = (question->qtype == kDNSType_A ? kDNSType_AAAA : kDNSType_A);
-    if (!mDNS_CheckForCacheRecord(m, question, qtype))
-    {
-        LogOperation("ShouldDeliverNegativeResponse:Question %##s (%s) not answering local question with negative unicast response"
-            " (can't find positive record)", question->qname.c, DNSTypeName(question->qtype));
-        return mDNSfalse;
-    }
-    LogOperation("ShouldDeliverNegativeResponse:Question %##s (%s) answering local with negative unicast response (found positive record)",
-        question->qname.c, DNSTypeName(question->qtype));
-    return mDNStrue;
-}
-
 // Workaround for networks using Microsoft Active Directory using "local" as a private internal
 // top-level domain
 mDNSlocal mStatus SendAdditionalQuery(DNSQuestion *q, request_state *request, mStatus err)
 {
-#ifndef UNICAST_DISABLED
     extern domainname ActiveDirectoryPrimaryDomain;
     DNSQuestion **question2;
     #define VALID_MSAD_SRV_TRANSPORT(T) (SameDomainLabel((T)->c, (const mDNSu8 *)"\x4_tcp") || SameDomainLabel((T)->c, (const mDNSu8 *)"\x4_udp"))
@@ -3080,9 +2556,6 @@
             *q2               = *q;
             q2->InterfaceID   = mDNSInterface_Unicast;
             q2->ExpectUnique  = mDNStrue;
-            // Always set the QuestionContext to indicate that this question should be stopped
-            // before freeing. Don't rely on "q".
-            q2->QuestionContext = request;
             // If the query starts as a single label e.g., somehost, and we have search domains with .local,
             // queryrecord_result_callback calls this function when .local is appended to "somehost".
             // At that time, the name in "q" is pointing at somehost.local and its qnameOrig pointing at
@@ -3091,7 +2564,7 @@
             if (q->qnameOrig)
             {
                 //(*question2)->qnameOrig =  mallocL("SendAdditionalQuery", DomainNameLength(q->qnameOrig));
-                (*question2)->qnameOrig =  os_malloc(DomainNameLength(q->qnameOrig));
+				(*question2)->qnameOrig =  os_malloc("SendAdditionalQuery", DomainNameLength(q->qnameOrig));
                 if (!(*question2)->qnameOrig) { LogMsg("SendAdditionalQuery: ERROR!!  malloc failure"); return mStatus_NoMemoryErr; }
                 (*question2)->qnameOrig->c[0] = 0;
                 AssignDomainName((*question2)->qnameOrig, q->qnameOrig);
@@ -3108,7 +2581,7 @@
             // "my-small-company.local" but *not* for "local", which is why the "local SOA" check would fail in that case.
             // We need to check against both ActiveDirectoryPrimaryDomain and SearchList. If it matches against either
             // of those, we don't want do the SOA check for the local
-            if (labels == 2 && !SameDomainName(&q->qname, &ActiveDirectoryPrimaryDomain) && !DomainInSearchList(&q->qname, mDNSfalse))
+			if (labels == 2 && !SameDomainName(&q->qname, &ActiveDirectoryPrimaryDomain) && !DomainInSearchList(&q->qname))
             {
                 AssignDomainName(&q2->qname, &localdomain);
                 q2->qtype          = kDNSType_SOA;
@@ -3121,26 +2594,17 @@
                 q2->RetryWithSearchDomains = mDNSfalse;
                 q2->SearchListIndex = 0;
                 q2->TimeoutQuestion = 0;
-                q2->AnonInfo        = mDNSNULL;
-                q2->pid             = request->process_id;
             }
             LogOperation("%3d: DNSServiceQueryRecord(%##s, %s) unicast", request->sd, q2->qname.c, DNSTypeName(q2->qtype));
             err = mDNS_StartQuery(&mDNSStorage, q2);
             if (err) LogMsg("%3d: ERROR: DNSServiceQueryRecord %##s %s mDNS_StartQuery: %d", request->sd, q2->qname.c, DNSTypeName(q2->qtype), (int)err);
         }
     return(err);
-#else // !UNICAST_DISABLED
-    (void) q;
-    (void) request;
-    (void) err;
-    
-    return mStatus_NoError;
-#endif // !UNICAST_DISABLED
 }
 #endif // APPLE_OSX_mDNSResponder
 
 // This function tries to append a search domain if valid and possible. If so, returns true.
-mDNSlocal mDNSBool RetryQuestionWithSearchDomains(mDNS *const m, DNSQuestion *question, request_state *req, QC_result AddRecord)
+mDNSlocal mDNSBool RetryQuestionWithSearchDomains(mDNS *const m, DNSQuestion *question, request_state *req)
 {
     int result;
     // RetryWithSearchDomains tells the core to call us back so that we can retry with search domains if there is no
@@ -3151,7 +2615,7 @@
     // If we get e.g., NXDOMAIN and the query is neither suppressed nor exhausted the domain search list and
     // is a valid question for appending search domains, retry by appending domains
 
-    if ((AddRecord != QC_suppressed) && question->SearchListIndex != -1 && question->AppendSearchDomains)
+	if (!question->SuppressQuery && question->SearchListIndex != -1 && question->AppendSearchDomains)
     {
         question->RetryWithSearchDomains = 0;
         result = AppendNewSearchDomain(m, question);
@@ -3183,188 +2647,18 @@
     }
     else
     {
-        LogInfo("%3d: RetryQuestionWithSearchDomains: Not appending search domains - SuppressQuery %d, SearchListIndex %d, AppendSearchDomains %d", req->sd, AddRecord, question->SearchListIndex, question->AppendSearchDomains);
+		LogInfo("%3d: RetryQuestionWithSearchDomains: Not appending search domains - SuppressQuery %d, SearchListIndex %d, AppendSearchDomains %d", req->sd, question->SuppressQuery, question->SearchListIndex, question->AppendSearchDomains);
     }
     return mDNSfalse;
 }
 
-mDNSlocal void queryrecord_result_reply(mDNS *const m, request_state *req, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord,
-    DNSServiceErrorType error)
+mDNSlocal void queryrecord_result_callback(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)
 {
     char name[MAX_ESCAPED_DOMAIN_NAME];
-    size_t len;
-    DNSServiceFlags flags = 0;
+	request_state *req = question->QuestionContext;
     reply_state *rep;
     char *data;
-
-    ConvertDomainNameToCString(answer->name, name);
-
-    LogOperation("%3d: %s(%##s, %s) %s %s", req->sd,
-                 req->hdr.op == query_request ? "DNSServiceQueryRecord" : "DNSServiceGetAddrInfo",
-                 question->qname.c, DNSTypeName(question->qtype), AddRecord ? "ADD" : "RMV", RRDisplayString(m, answer));
-
-    len = sizeof(DNSServiceFlags);  // calculate reply data length
-    len += sizeof(mDNSu32);     // interface index
-    len += sizeof(DNSServiceErrorType);
-    len += strlen(name) + 1;
-    len += 3 * sizeof(mDNSu16); // type, class, rdlen
-    len += answer->rdlength;
-    len += sizeof(mDNSu32);     // TTL
-
-    rep = create_reply(req->hdr.op == query_request ? query_reply_op : addrinfo_reply_op, len, req);
-
-    if (AddRecord)
-        flags |= kDNSServiceFlagsAdd;    
-    if (question->ValidationStatus != 0)
-    {
-        error =   kDNSServiceErr_NoError;
-        if (question->ValidationRequired && question->ValidationState == DNSSECValDone)
-        {
-            switch (question->ValidationStatus) //Set the dnssec flags to be passed on to the Apps here
-            {
-            case DNSSEC_Secure:
-                flags |= kDNSServiceFlagsSecure;
-                break;
-            case DNSSEC_Insecure:
-                flags |= kDNSServiceFlagsInsecure;
-                break;
-            case DNSSEC_Indeterminate:
-                flags |= kDNSServiceFlagsIndeterminate;
-                break;
-            case DNSSEC_Bogus:
-                flags |= kDNSServiceFlagsBogus;
-                break;
-            default:
-                LogMsg("queryrecord_result_reply unknown status %d for %##s", question->ValidationStatus, question->qname.c);
-            }
-        }
-    }
-    
-    rep->rhdr->flags = dnssd_htonl(flags);
-    // Call mDNSPlatformInterfaceIndexfromInterfaceID, but suppressNetworkChange (last argument). Otherwise, if the
-    // InterfaceID is not valid, then it simulates a "NetworkChanged" which in turn makes questions
-    // to be stopped and started including  *this* one. Normally the InterfaceID is valid. But when we
-    // are using the /etc/hosts entries to answer a question, the InterfaceID may not be known to the
-    // mDNS core . Eventually, we should remove the calls to "NetworkChanged" in
-    // mDNSPlatformInterfaceIndexfromInterfaceID when it can't find InterfaceID as ResourceRecords
-    // should not have existed to answer this question if the corresponding interface is not valid.
-    rep->rhdr->ifi   = dnssd_htonl(mDNSPlatformInterfaceIndexfromInterfaceID(m, answer->InterfaceID, mDNStrue));
-    rep->rhdr->error = dnssd_htonl(error);
-
-    data = (char *)&rep->rhdr[1];
-
-    put_string(name,             &data);
-    put_uint16(answer->rrtype,   &data);
-    put_uint16(answer->rrclass,  &data);
-    put_uint16(answer->rdlength, &data);
-    // We need to use putRData here instead of the crude put_rdata function, because the crude put_rdata
-    // function just does a blind memory copy without regard to structures that may have holes in them.
-    if (answer->rdlength)
-        if (!putRData(mDNSNULL, (mDNSu8 *)data, (mDNSu8 *)rep->rhdr + len, answer))
-            LogMsg("queryrecord_result_reply putRData failed %d", (mDNSu8 *)rep->rhdr + len - (mDNSu8 *)data);
-    data += answer->rdlength;
-    put_uint32(AddRecord ? answer->rroriginalttl : 0, &data);
-
-    append_reply(req, rep);
-    // Stop the question, if we just timed out
-    if (error == kDNSServiceErr_Timeout)
-    {
-        mDNS_StopQuery(m, question);
-        // Reset the pointers so that we don't call stop on termination
-        question->QuestionContext = mDNSNULL;
-    }
-    else if ((AddRecord == QC_add) && req->hdr.op == addrinfo_request)
-    {
-        // Note: We count all answers including LocalOnly e.g., /etc/hosts. If we
-        // exclude that, v4ans/v6ans will be zero and we would wrongly think that
-        // we did not answer questions and setup the status to deliver triggers.
-        if (question->qtype == kDNSType_A)
-            req->u.addrinfo.v4ans = 1;
-        if (question->qtype == kDNSType_AAAA)
-            req->u.addrinfo.v6ans = 1;
-    }
-    else if ((AddRecord == QC_add) && req->hdr.op == query_request)
-    {
-        if (question->qtype == kDNSType_A || question->qtype == kDNSType_AAAA)
-            req->u.queryrecord.ans = 1;
-    }
-
-#if APPLE_OSX_mDNSResponder
-#if !NO_WCF
-    CHECK_WCF_FUNCTION(WCFIsServerRunning)
-    {
-        struct xucred x;
-        socklen_t xucredlen = sizeof(x);
-
-        if (WCFIsServerRunning((WCFConnection *)m->WCF) && answer->rdlength != 0)
-        {
-            if (getsockopt(req->sd, 0, LOCAL_PEERCRED, &x, &xucredlen) >= 0 &&
-                (x.cr_version == XUCRED_VERSION))
-            {
-                struct sockaddr_storage addr;
-                const RDataBody2 *const rdb = (RDataBody2 *)answer->rdata->u.data;
-                addr.ss_len = 0;
-                if (answer->rrtype == kDNSType_A || answer->rrtype == kDNSType_AAAA)
-                {
-                    if (answer->rrtype == kDNSType_A)
-                    {
-                        struct sockaddr_in *sin = (struct sockaddr_in *)&addr;
-                        sin->sin_port = 0;
-                        if (!putRData(mDNSNULL, (mDNSu8 *)&sin->sin_addr, (mDNSu8 *)(&sin->sin_addr + sizeof(rdb->ipv4)), answer))
-                            LogMsg("queryrecord_result_reply: WCF AF_INET putRData failed");
-                        else
-                        {
-                            addr.ss_len = sizeof (struct sockaddr_in);
-                            addr.ss_family = AF_INET;
-                        }
-                    }
-                    else if (answer->rrtype == kDNSType_AAAA)
-                    {
-                        struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&addr;
-                        sin6->sin6_port = 0;
-                        if (!putRData(mDNSNULL, (mDNSu8 *)&sin6->sin6_addr, (mDNSu8 *)(&sin6->sin6_addr + sizeof(rdb->ipv6)), answer))
-                            LogMsg("queryrecord_result_reply: WCF AF_INET6 putRData failed");
-                        else
-                        {
-                            addr.ss_len = sizeof (struct sockaddr_in6);
-                            addr.ss_family = AF_INET6;
-                        }
-                    }
-                    if (addr.ss_len)
-                    {
-                        debugf("queryrecord_result_reply: Name %s, uid %u, addr length %d", name, x.cr_uid, addr.ss_len);
-                        CHECK_WCF_FUNCTION((WCFConnection *)WCFNameResolvesToAddr)
-                        {
-                            WCFNameResolvesToAddr(m->WCF, name, (struct sockaddr *)&addr, x.cr_uid);
-                        }
-                    }
-                }
-                else if (answer->rrtype == kDNSType_CNAME)
-                {
-                    domainname cname;
-                    char cname_cstr[MAX_ESCAPED_DOMAIN_NAME];
-                    if (!putRData(mDNSNULL, cname.c, (mDNSu8 *)(cname.c + MAX_DOMAIN_NAME), answer))
-                        LogMsg("queryrecord_result_reply: WCF CNAME putRData failed");
-                    else
-                    {
-                        ConvertDomainNameToCString(&cname, cname_cstr);
-                        CHECK_WCF_FUNCTION((WCFConnection *)WCFNameResolvesToAddr)
-                        {
-                            WCFNameResolvesToName(m->WCF, name, cname_cstr, x.cr_uid);
-                        }
-                    }
-                }
-            }
-            else my_perror("queryrecord_result_reply: ERROR: getsockopt LOCAL_PEERCRED");
-        }
-    }
-#endif
-#endif
-}
-
-mDNSlocal void queryrecord_result_callback(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)
-{
-    request_state *req = question->QuestionContext;
+	size_t len;
     DNSServiceErrorType error = kDNSServiceErr_NoError;
     DNSQuestion *q = mDNSNULL;
 
@@ -3435,14 +2729,14 @@
             question->AppendLocalSearchDomains = 0;
         }
 
-        if (q && AddRecord && AddRecord != QC_dnssec && (question->InterfaceID == mDNSInterface_Unicast) && !answer->rdlength)
+	if (q && AddRecord && (question->InterfaceID == mDNSInterface_Unicast) && !answer->rdlength)
         {
             // If we get a negative response to the unicast query that we sent above, retry after appending search domains
             // Note: We could have appended search domains below (where do it for regular unicast questions) instead of doing it here.
             // As we ignore negative unicast answers below, we would never reach the code where the search domains are appended.
             // To keep things simple, we handle unicast ".local" separately here.
             LogInfo("queryrecord_result_callback: Retrying .local question %##s (%s) as unicast after appending search domains", question->qname.c, DNSTypeName(question->qtype));
-            if (RetryQuestionWithSearchDomains(m, question, req, AddRecord))
+		if (RetryQuestionWithSearchDomains(m, question, req))
                 return;
             if (question->AppendSearchDomains && !question->AppendLocalSearchDomains && IsLocalDomain(&question->qname))
             {
@@ -3459,18 +2753,6 @@
     }
 #endif // APPLE_OSX_mDNSResponder
 
-    // If a query is being suppressed for some reason, we don't have to do any other
-    // processing.
-    //
-    // Note: We don't check for "SuppressQuery" and instead use QC_suppressed because
-    // the "core" needs to temporarily turn off SuppressQuery to answer this query.
-    if (AddRecord == QC_suppressed)
-    {
-        LogInfo("queryrecord_result_callback: Suppressed question %##s (%s)", question->qname.c, DNSTypeName(question->qtype));
-        queryrecord_result_reply(m, req, question, answer, AddRecord, kDNSServiceErr_NoSuchRecord);
-        return;
-    }
-
     if (answer->RecordType == kDNSRecordTypePacketNegative)
     {
         // If this question needs to be timed out and we have reached the stop time, mark
@@ -3498,64 +2780,170 @@
         {
             if (!answer->InterfaceID && IsLocalDomain(answer->name))
             {
-                // Sanity check: "q" will be set only if "question" is the .local unicast query.
-                if (!q)
+				LogInfo("queryrecord_result_callback:Question %##s (%s) answering local with unicast", question->qname.c, DNSTypeName(question->qtype));
+				return;
+				}
+			error = kDNSServiceErr_NoSuchRecord;
+			}
+		AddRecord = mDNStrue;
+		}
+	// If we get a negative answer, try appending search domains. Don't append search domains
+	// - if we are timing out this question
+	// - if the negative response was received as a result of a multicast query
+	// - if this is an additional query (q2), we already appended search domains above (indicated by "!q" below)
+	if (error != kDNSServiceErr_Timeout)
+		{
+		if (!q && !answer->InterfaceID && !answer->rdlength && AddRecord)
                 {
-                    LogMsg("queryrecord_result_callback: ERROR!! answering multicast question %s with unicast cache record",
-                        RRDisplayString(m, answer));
+			// If the original question did not end in .local, we did not send an SOA query
+			// to figure out whether we should send an additional unicast query or not. If we just
+			// appended .local, we need to see if we need to send an additional query. This should
+			// normally happen just once because after we append .local, we ignore all negative
+			// responses for .local above.
+			LogInfo("queryrecord_result_callback: Retrying question %##s (%s) after appending search domains", question->qname.c, DNSTypeName(question->qtype));
+			if (RetryQuestionWithSearchDomains(m, question, req))
+				{
+				// Note: We need to call SendAdditionalQuery every time after appending a search domain as .local could
+				// be anywhere in the search domain list.
+#if APPLE_OSX_mDNSResponder
+				mStatus err = mStatus_NoError;
+				err = SendAdditionalQuery(question, req, err);
+				if (err) LogMsg("queryrecord_result_callback: Sending .local SOA query failed, after appending domains");
+#endif // APPLE_OSX_mDNSResponder
                     return;
                 }
-#if APPLE_OSX_mDNSResponder
-                if (!ShouldDeliverNegativeResponse(m, question))
+			}
+		}
+
+	ConvertDomainNameToCString(answer->name, name);
+
+	LogOperation("%3d: %s(%##s, %s) %s %s", req->sd,
+		req->hdr.op == query_request ? "DNSServiceQueryRecord" : "DNSServiceGetAddrInfo",
+		question->qname.c, DNSTypeName(question->qtype), AddRecord ? "ADD" : "RMV", RRDisplayString(m, answer));
+
+	len = sizeof(DNSServiceFlags);	// calculate reply data length
+	len += sizeof(mDNSu32);		// interface index
+	len += sizeof(DNSServiceErrorType);
+	len += strlen(name) + 1;
+	len += 3 * sizeof(mDNSu16);	// type, class, rdlen
+	len += answer->rdlength;
+	len += sizeof(mDNSu32);		// TTL
+
+	rep = create_reply(req->hdr.op == query_request ? query_reply_op : addrinfo_reply_op, len, req);
+
+	rep->rhdr->flags = dnssd_htonl(AddRecord ? kDNSServiceFlagsAdd : 0);
+	// Call mDNSPlatformInterfaceIndexfromInterfaceID, but suppressNetworkChange (last argument). Otherwise, if the
+	// InterfaceID is not valid, then it simulates a "NetworkChanged" which in turn makes questions
+	// to be stopped and started including  *this* one. Normally the InterfaceID is valid. But when we
+	// are using the /etc/hosts entries to answer a question, the InterfaceID may not be known to the
+	// mDNS core . Eventually, we should remove the calls to "NetworkChanged" in
+	// mDNSPlatformInterfaceIndexfromInterfaceID when it can't find InterfaceID as ResourceRecords
+	// should not have existed to answer this question if the corresponding interface is not valid.
+	rep->rhdr->ifi   = dnssd_htonl(mDNSPlatformInterfaceIndexfromInterfaceID(m, answer->InterfaceID, mDNStrue));
+	rep->rhdr->error = dnssd_htonl(error);
+
+	data = (char *)&rep->rhdr[1];
+
+	put_string(name,             &data);
+	put_uint16(answer->rrtype,   &data);
+	put_uint16(answer->rrclass,  &data);
+	put_uint16(answer->rdlength, &data);
+	// We need to use putRData here instead of the crude put_rdata function, because the crude put_rdata
+	// function just does a blind memory copy without regard to structures that may have holes in them.
+	if (answer->rdlength)
+		if (!putRData(mDNSNULL, (mDNSu8 *)data, (mDNSu8 *)rep->rhdr + len, answer))
+			LogMsg("queryrecord_result_callback putRData failed %d", (mDNSu8 *)rep->rhdr + len - (mDNSu8 *)data);
+	data += answer->rdlength;
+	put_uint32(AddRecord ? answer->rroriginalttl : 0, &data);
+
+	append_reply(req, rep);
+	// Stop the question, if we just timed out
+	if (error == kDNSServiceErr_Timeout)
+		{
+		mDNS_StopQuery(m, question);
+		// Reset the pointers so that we don't call stop on termination
+		question->QuestionContext = mDNSNULL;
+		}
+#if APPLE_OSX_mDNSResponder
+#if ! NO_WCF
+	CHECK_WCF_FUNCTION(WCFIsServerRunning)
+		{
+		struct xucred x;
+		socklen_t xucredlen = sizeof(x);
+	
+		if (WCFIsServerRunning((WCFConnection *)m->WCF) && answer->rdlength != 0)
+			{
+			if (getsockopt(req->sd, 0, LOCAL_PEERCRED, &x, &xucredlen) >= 0 &&
+				(x.cr_version == XUCRED_VERSION))
+				{
+				struct sockaddr_storage addr;
+				const RDataBody2 *const rdb = (RDataBody2 *)answer->rdata->u.data;
+				addr.ss_len = 0;
+				if (answer->rrtype == kDNSType_A || answer->rrtype == kDNSType_AAAA)
+					{
+					if (answer->rrtype == kDNSType_A)
+						{
+						struct sockaddr_in *sin = (struct sockaddr_in *)&addr;
+						sin->sin_port = 0;
+						if (!putRData(mDNSNULL, (mDNSu8 *)&sin->sin_addr, (mDNSu8 *)(&sin->sin_addr + sizeof(rdb->ipv4)), answer))
+							LogMsg("queryrecord_result_callback: WCF AF_INET putRData failed");
+						else
+							{
+							addr.ss_len = sizeof (struct sockaddr_in);
+							addr.ss_family = AF_INET;
+							}
+						}
+					else if (answer->rrtype == kDNSType_AAAA)
+						{
+						struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&addr;
+						sin6->sin6_port = 0;
+						if (!putRData(mDNSNULL, (mDNSu8 *)&sin6->sin6_addr, (mDNSu8 *)(&sin6->sin6_addr + sizeof(rdb->ipv6)), answer))
+							LogMsg("queryrecord_result_callback: WCF AF_INET6 putRData failed");
+						else
+							{
+							addr.ss_len = sizeof (struct sockaddr_in6);
+							addr.ss_family = AF_INET6;
+							}
+						}
+					if (addr.ss_len)
                 {
-                    return;
-                }
-#endif  // APPLE_OSX_mDNSResponder
-                LogInfo("queryrecord_result_callback:Question %##s (%s) answering local with negative unicast response", question->qname.c,
-                    DNSTypeName(question->qtype));
+						debugf("queryrecord_result_callback: Name %s, uid %u, addr length %d", name, x.cr_uid, addr.ss_len);
+						CHECK_WCF_FUNCTION((WCFConnection *)WCFNameResolvesToAddr)
+							{
+							WCFNameResolvesToAddr(m->WCF, name, (struct sockaddr *)&addr, x.cr_uid);
             }
-            error = kDNSServiceErr_NoSuchRecord;
         }
     }
-    // If we get a negative answer, try appending search domains. Don't append search domains
-    // - if we are timing out this question
-    // - if the negative response was received as a result of a multicast query
-    // - if this is an additional query (q2), we already appended search domains above (indicated by "!q" below)
-    // - if this response is forced e.g., dnssec validation result
-    if (error != kDNSServiceErr_Timeout)
+				else if (answer->rrtype == kDNSType_CNAME)
     {
-        if (!q && !answer->InterfaceID && !answer->rdlength && AddRecord && AddRecord != QC_dnssec)
+					domainname cname;
+					char cname_cstr[MAX_ESCAPED_DOMAIN_NAME];
+					if (!putRData(mDNSNULL, cname.c, (mDNSu8 *)(cname.c + MAX_DOMAIN_NAME), answer))
+							LogMsg("queryrecord_result_callback: WCF CNAME putRData failed");
+					else
         {
-            // If the original question did not end in .local, we did not send an SOA query
-            // to figure out whether we should send an additional unicast query or not. If we just
-            // appended .local, we need to see if we need to send an additional query. This should
-            // normally happen just once because after we append .local, we ignore all negative
-            // responses for .local above.
-            LogInfo("queryrecord_result_callback: Retrying question %##s (%s) after appending search domains", question->qname.c, DNSTypeName(question->qtype));
-            if (RetryQuestionWithSearchDomains(m, question, req, AddRecord))
+						ConvertDomainNameToCString(&cname, cname_cstr);
+						CHECK_WCF_FUNCTION((WCFConnection *)WCFNameResolvesToAddr)
             {
-                // Note: We need to call SendAdditionalQuery every time after appending a search domain as .local could
-                // be anywhere in the search domain list.
-#if APPLE_OSX_mDNSResponder
-                mStatus err = mStatus_NoError;
-                err = SendAdditionalQuery(question, req, err);
-                if (err) LogMsg("queryrecord_result_callback: Sending .local SOA query failed, after appending domains");
-#endif // APPLE_OSX_mDNSResponder
-                return;
+							WCFNameResolvesToName(m->WCF, name, cname_cstr, x.cr_uid);
             }
         }
     }
-    queryrecord_result_reply(m, req, question, answer, AddRecord, error);
+				}
+			else my_perror("queryrecord_result_callback: ERROR: getsockopt LOCAL_PEERCRED");
+			}
+		}
+#endif
+#endif
 }
 
 mDNSlocal void queryrecord_termination_callback(request_state *request)
 {
-    LogOperation("%3d: DNSServiceQueryRecord(%##s, %s) STOP PID[%d](%s)",
-		request->sd, request->u.queryrecord.q.qname.c, DNSTypeName(request->u.queryrecord.q.qtype), request->process_id, request->pid_name);
+	LogOperation("%3d: DNSServiceQueryRecord(%##s, %s) STOP",
+		request->sd, request->u.queryrecord.q.qname.c, DNSTypeName(request->u.queryrecord.q.qtype));
     if (request->u.queryrecord.q.QuestionContext)
     {
         mDNS_StopQuery(&mDNSStorage, &request->u.queryrecord.q);  // no need to error check
-        LogMcastQ(&mDNSStorage, &request->u.queryrecord.q, request, q_stop);
         request->u.queryrecord.q.QuestionContext = mDNSNULL;
     }
     else
@@ -3566,14 +2954,14 @@
 
     if (request->u.queryrecord.q.qnameOrig)
     {
+		//freeL("QueryTermination", request->u.queryrecord.q.qnameOrig);
         os_free(request->u.queryrecord.q.qnameOrig);
         request->u.queryrecord.q.qnameOrig = mDNSNULL;
     }
-
-    if (callExternalHelpers(request->u.queryrecord.q.InterfaceID, &request->u.queryrecord.q.qname, request->flags))
+	if (request->u.queryrecord.q.InterfaceID == mDNSInterface_P2P || (!request->u.queryrecord.q.InterfaceID && SameDomainName((const domainname *)LastLabel(&request->u.queryrecord.q.qname), &localdomain) && (request->flags & kDNSServiceFlagsIncludeP2P)))
     {
         LogInfo("queryrecord_termination_callback: calling external_stop_browsing_for_service()");
-        external_stop_browsing_for_service(request->u.queryrecord.q.InterfaceID, &request->u.queryrecord.q.qname, request->u.queryrecord.q.qtype, request->flags);
+		external_stop_browsing_for_service(&mDNSStorage, &request->u.queryrecord.q.qname, request->u.queryrecord.q.qtype);
     }
     if (request->u.queryrecord.q2)
     {
@@ -3581,7 +2969,6 @@
         {
             LogInfo("queryrecord_termination_callback: Stopping q2 %##s", request->u.queryrecord.q2->qname.c);
             mDNS_StopQuery(&mDNSStorage, request->u.queryrecord.q2);
-            LogMcastQ(&mDNSStorage, request->u.queryrecord.q2, request, q_stop);
         }
         else
         {
@@ -3591,56 +2978,14 @@
         if (request->u.queryrecord.q2->qnameOrig)
         {
             LogInfo("queryrecord_termination_callback: freeing q2 qnameOrig %##s", request->u.queryrecord.q2->qnameOrig->c);
+ 			//freeL("QueryTermination q2", request->u.queryrecord.q2->qnameOrig);
             os_free(request->u.queryrecord.q2->qnameOrig);
             request->u.queryrecord.q2->qnameOrig = mDNSNULL;
         }
+  		//freeL("queryrecord Q2", request->u.queryrecord.q2);
         os_free(request->u.queryrecord.q2);
         request->u.queryrecord.q2 = mDNSNULL;
     }
-#if APPLE_OSX_mDNSResponder
-    {
-        if (request->u.queryrecord.ans)
-        {
-            DNSQuestion *v4q, *v6q;
-            // If we are receiving poisitive answers, provide the hint to the
-            // upper layer.
-            v4q = v6q = mDNSNULL;
-            if (request->u.queryrecord.q.qtype == kDNSType_A)
-                v4q = &request->u.queryrecord.q;
-            else if (request->u.queryrecord.q.qtype == kDNSType_AAAA)
-                v6q = &request->u.queryrecord.q;
-            mDNSPlatformTriggerDNSRetry(&mDNSStorage, v4q, v6q);
-        }
-    }
-#endif // APPLE_OSX_mDNSResponder
-}
-
-mDNSlocal void SetQuestionPolicy(DNSQuestion *q, request_state *req)
-{
-    int i;
-
-    // The policy is either based on pid or UUID. Pass a zero pid
-    // to the "core" if the UUID is valid. If we always pass the pid,
-    // then the "core" needs to determine whether the uuid is valid 
-    // by examining all the 16 bytes at the time of the policy
-    // check and also when setting the delegate socket option. Also, it
-    // requires that we zero out the uuid wherever the question is
-    // initialized to make sure that it is not interpreted as valid.
-    // To prevent these intrusive changes, just pass a zero pid to indicate
-    // that pid is not valid when uuid is valid. In future if we need the
-    // pid in the question, we will reevaluate this strategy.
-    if (req->validUUID)
-    {
-        for (i = 0; i < UUID_SIZE; i++)
-        {
-            q->uuid[i] = req->uuid[i];
-        }
-        q->pid = 0;
-    }
-    else
-    {
-        q->pid = req->process_id;
-    }
 }
 
 mDNSlocal mStatus handle_queryrecord_request(request_state *request)
@@ -3668,7 +3013,6 @@
     mDNSPlatformMemZero(&request->u.queryrecord, sizeof(request->u.queryrecord));
 
     q->InterfaceID      = InterfaceID;
-    q->flags            = flags;
     q->Target           = zeroAddr;
     if (!MakeDomainNameFromDNSNameString(&q->qname, name)) return(mStatus_BadParamErr);
 #if 0
@@ -3683,36 +3027,20 @@
     q->SuppressUnusable = (flags & kDNSServiceFlagsSuppressUnusable   ) != 0;
     q->TimeoutQuestion  = (flags & kDNSServiceFlagsTimeout            ) != 0;
     q->WakeOnResolve    = 0;
-    q->UseBackgroundTrafficClass = (flags & kDNSServiceFlagsBackgroundTrafficClass) != 0;
-    if ((flags & kDNSServiceFlagsValidate) != 0)
-        q->ValidationRequired = DNSSEC_VALIDATION_SECURE;
-    else if ((flags & kDNSServiceFlagsValidateOptional) != 0)
-        q->ValidationRequired = DNSSEC_VALIDATION_SECURE_OPTIONAL;
-    q->ValidatingResponse = 0;
-    q->ProxyQuestion    = 0;
-    q->AnonInfo = mDNSNULL;
     q->QuestionCallback = queryrecord_result_callback;
     q->QuestionContext  = request;
     q->SearchListIndex  = 0;
 
-    q->DNSSECAuthInfo = mDNSNULL;
-    q->DAIFreeCallback = mDNSNULL;
-
-    //Turn off dnssec validation for local domains and Question Types: RRSIG/ANY(ANY Type is not supported yet)
-    if ((IsLocalDomain(&q->qname)) || (q->qtype == kDNSServiceType_RRSIG) || (q->qtype == kDNSServiceType_ANY))
-        q->ValidationRequired = 0;
-          
     // Don't append search domains for fully qualified domain names including queries
     // such as e.g., "abc." that has only one label. We convert all names to FQDNs as internally
     // we only deal with FQDNs. Hence, we cannot look at qname to figure out whether we should
     // append search domains or not.  So, we record that information in AppendSearchDomains.
     //
-    // We append search domains only for queries that are a single label. If overriden using command line 
-    // argument "AlwaysAppendSearchDomains", then we do it for any query which is not fully qualified.
-    // For DNSSEC questions, append search domains only if kDNSServiceFlagsValidateOptional is set.
+	// We append search domains only for queries that are a single label. If overriden using
+	// command line argument "AlwaysAppendSearchDomains", then we do it for any query which
+	// is not fully qualified.
 
-    if ((!(q->ValidationRequired == DNSSEC_VALIDATION_SECURE)) && (!(q->ValidationRequired == DNSSEC_VALIDATION_INSECURE)) 
-        && (rrtype == kDNSType_A || rrtype == kDNSType_AAAA) && name[strlen(name) - 1] != '.' &&
+	if ((rrtype == kDNSType_A || rrtype == kDNSType_AAAA) && name[strlen(name) - 1] != '.' &&
         (AlwaysAppendSearchDomains || CountLabels(&q->qname) == 1)) 
     {
         q->AppendSearchDomains = 1;
@@ -3730,22 +3058,17 @@
     // the cache
     q->RetryWithSearchDomains = ApplySearchDomainsFirst(q) ? 1 : 0;
     q->qnameOrig        = mDNSNULL;
-    SetQuestionPolicy(q, request);
 
-    LogOperation("%3d: DNSServiceQueryRecord(%X, %d, %##s, %s) START PID[%d](%s)", 
-		request->sd, flags, interfaceIndex, q->qname.c, DNSTypeName(q->qtype), request->process_id, request->pid_name);
+	LogOperation("%3d: DNSServiceQueryRecord(%X, %d, %##s, %s) START", request->sd, flags, interfaceIndex, q->qname.c, DNSTypeName(q->qtype));
     err = mDNS_StartQuery(&mDNSStorage, q);
-   
-    if (err) 
-        LogMsg("%3d: ERROR: DNSServiceQueryRecord %##s %s mDNS_StartQuery: %d", request->sd, q->qname.c, DNSTypeName(q->qtype), (int)err);
+	if (err) LogMsg("%3d: ERROR: DNSServiceQueryRecord %##s %s mDNS_StartQuery: %d", request->sd, q->qname.c, DNSTypeName(q->qtype), (int)err);
     else
     {
         request->terminate = queryrecord_termination_callback;
-        LogMcastQ(&mDNSStorage, q, request, q_start);
-        if (callExternalHelpers(q->InterfaceID, &q->qname, flags))
+		if (q->InterfaceID == mDNSInterface_P2P || (!q->InterfaceID && SameDomainName((const domainname *)LastLabel(&q->qname), &localdomain) && (flags & kDNSServiceFlagsIncludeP2P)))
         {
             LogInfo("handle_queryrecord_request: calling external_start_browsing_for_service()");
-            external_start_browsing_for_service(q->InterfaceID, &q->qname, q->qtype, flags);
+			external_start_browsing_for_service(&mDNSStorage, &q->qname, q->qtype);
         }
     }
 
@@ -3785,17 +3108,6 @@
 
 mDNSlocal void enum_termination_callback(request_state *request)
 {
-    // Stop the domain enumeration queries to discover the WAB Browse/Registration domains
-    if (request->u.enumeration.flags & kDNSServiceFlagsRegistrationDomains)
-    {
-        LogInfo("%3d: DNSServiceEnumeration Cancel WAB Registration PID[%d](%s)", request->sd, request->process_id, request->pid_name);
-        uDNS_StopWABQueries(&mDNSStorage, UDNS_WAB_REG_QUERY);
-    }
-    else
-    {
-        LogInfo("%3d: DNSServiceEnumeration Cancel WAB Browse PID[%d](%s)", request->sd, request->process_id, request->pid_name);
-        uDNS_StopWABQueries(&mDNSStorage, UDNS_WAB_BROWSE_QUERY);
-    }
     mDNS_StopGetDomains(&mDNSStorage, &request->u.enumeration.q_all);
     mDNS_StopGetDomains(&mDNSStorage, &request->u.enumeration.q_default);
 }
@@ -3851,8 +3163,13 @@
     if (!request->msgptr)
     { LogMsg("%3d: DNSServiceEnumerateDomains(unreadable parameters)", request->sd); return(mStatus_BadParamErr); }
 
-    // mark which kind of enumeration we're doing so that we know what domain enumeration queries to stop
+	// allocate context structures
+	uDNS_SetupSearchDomains(&mDNSStorage, UDNS_START_WAB_QUERY);
+
+#if 0
+	// mark which kind of enumeration we're doing so we can (de)authorize certain domains
     request->u.enumeration.flags = reg;
+#endif
 
     // enumeration requires multiple questions, so we must link all the context pointers so that
     // necessary context can be reached from the callbacks
@@ -3873,20 +3190,6 @@
         if (err) mDNS_StopGetDomains(&mDNSStorage, &request->u.enumeration.q_all);
         else request->terminate = enum_termination_callback;
     }
-    if (!err)
-    {
-        // Start the domain enumeration queries to discover the WAB Browse/Registration domains
-        if (reg)
-        {
-            LogInfo("%3d: DNSServiceEnumerateDomains Start WAB Registration PID[%d](%s)", request->sd, request->process_id, request->pid_name);
-            uDNS_StartWABQueries(&mDNSStorage, UDNS_WAB_REG_QUERY);
-        }
-        else 
-        {
-            LogInfo("%3d: DNSServiceEnumerateDomains Start WAB Browse PID[%d](%s)", request->sd, request->process_id, request->pid_name);
-            uDNS_StartWABQueries(&mDNSStorage, UDNS_WAB_BROWSE_QUERY);
-        }
-    }
 
     return(err);
 }
@@ -3910,61 +3213,12 @@
             "%3d: DNSServiceReconfirmRecord(%s) interface %d failed: %d",
             request->sd, RRDisplayString(&mDNSStorage, &rr->resrec),
             mDNSPlatformInterfaceIndexfromInterfaceID(&mDNSStorage, rr->resrec.InterfaceID, mDNSfalse), status);
+		//freeL("AuthRecord/handle_reconfirm_request", rr);
         os_free(rr);
     }
     return(status);
 }
 
-#if APPLE_OSX_mDNSResponder
-
-mDNSlocal mStatus handle_release_request(request_state *request)
-{
-    mStatus err = 0;
-    //char name[256], regtype[MAX_ESCAPED_DOMAIN_NAME], domain[MAX_ESCAPED_DOMAIN_NAME];
-    char name[64], regtype[MAX_ESCAPED_DOMAIN_NAME], domain[MAX_ESCAPED_DOMAIN_NAME];
-    domainname instance;
-
-    // extract the data from the message
-    DNSServiceFlags flags = get_flags(&request->msgptr, request->msgend);
-
-    //if (get_string(&request->msgptr, request->msgend, name, 256) < 0 ||
-    if (get_string(&request->msgptr, request->msgend, name, 64) < 0 ||
-        get_string(&request->msgptr, request->msgend, regtype, MAX_ESCAPED_DOMAIN_NAME) < 0 ||
-        get_string(&request->msgptr, request->msgend, domain, MAX_ESCAPED_DOMAIN_NAME) < 0)
-    {
-        LogMsg("ERROR: handle_release_request - Couldn't read name/regtype/domain");
-        return(mStatus_BadParamErr);
-    }
-
-    if (!request->msgptr)
-    {
-        LogMsg("%3d: PeerConnectionRelease(unreadable parameters)", request->sd);
-        return(mStatus_BadParamErr);
-    }
-
-    if (build_domainname_from_strings(&instance, name, regtype, domain) < 0)
-    {
-        LogMsg("ERROR: handle_release_request bad “%s” “%s” “%s”", name, regtype, domain);
-        return(mStatus_BadParamErr);
-    }
-
-    LogOperation("%3d: PeerConnectionRelease(%X %##s) START PID[%d](%s)",
-                 request->sd, flags, instance.c, request->process_id, request->pid_name);
-    
-    external_connection_release(&instance);
-    return(err);
-}
-
-#else   // APPLE_OSX_mDNSResponder
-
-mDNSlocal mStatus handle_release_request(request_state *request)
-{
-    (void) request; 
-    return mStatus_UnsupportedErr;
-}
-
-#endif  // APPLE_OSX_mDNSResponder
-
 mDNSlocal mStatus handle_setdomain_request(request_state *request)
 {
     char domainstr[MAX_ESCAPED_DOMAIN_NAME];
@@ -4006,110 +3260,6 @@
     send_all(request->sd, (const char *)&BadParamErr, sizeof(BadParamErr));
 }
 
-#ifdef APPLE_OSX_mDNSResponder
-// The caller can specify either the pid or the uuid. If the pid is not specified,
-// update the effective uuid. Don't overwrite the pid which is used for debugging
-// purposes and initialized when the socket is opened.
-mDNSlocal void handle_connection_delegate_request(request_state *request)
-{
-    mDNSs32 pid;
-    socklen_t len;
-
-    len = 0;
-    pid = get_uint32(&request->msgptr, request->msgend);
-#ifdef LOCAL_PEEREPID
-    if (pid)
-    {
-        len = sizeof(pid);
-        if (getsockopt(request->sd, SOL_LOCAL, LOCAL_PEEREPID, &request->process_id, &len) != 0)
-            return;
-        // to extract the process name from the pid value
-        if (proc_pidinfo(request->process_id, PROC_PIDT_SHORTBSDINFO, 1, &proc, PROC_PIDT_SHORTBSDINFO_SIZE) == 0)
-            return;
-        mDNSPlatformStrCopy(request->pid_name, proc.pbsi_comm);
-        //LogMsg("handle_connection_delegate_request: process id %d, name %s", request->process_id, request->pid_name);
-    }
-#endif
-#ifdef LOCAL_PEEREUUID
-    if (!pid)
-    {
-        len = UUID_SIZE;
-        if (getsockopt(request->sd, SOL_LOCAL, LOCAL_PEEREUUID, request->uuid, &len) != 0)
-            return;
-        request->validUUID = mDNStrue;
-    }
-#endif
-}
-#else
-mDNSlocal void handle_connection_delegate_request(request_state *request)
-{
-    (void) request;
-}
-#endif
-
-typedef packedstruct
-{
-    mStatus err;
-    mDNSs32 pid;
-} PIDInfo;
-
-mDNSlocal void handle_getpid_request(request_state *request)
-{
-    const request_state *req;
-    mDNSs32 pid = -1;
-    mDNSu16 srcport = get_uint16(&request->msgptr, request->msgend);
-    const DNSQuestion *q = NULL;
-    PIDInfo pi;
-
-    LogOperation("%3d: DNSServiceGetPID START", request->sd);
-
-    for (req = all_requests; req; req=req->next)
-    {
-        if (req->hdr.op == query_request)
-            q = &req->u.queryrecord.q;
-        else if (req->hdr.op == addrinfo_request)
-            q = &req->u.addrinfo.q4;
-        else if (req->hdr.op == addrinfo_request)
-            q = &req->u.addrinfo.q6;
-
-        if (q && q->LocalSocket != NULL)
-        {
-            mDNSu16 port = mDNSPlatformGetUDPPort(q->LocalSocket);
-            if (port == srcport)
-            {
-                pid = req->process_id;
-                LogInfo("DNSServiceGetPID: srcport %d, pid %d [%s] question %##s", htons(srcport), pid, req->pid_name, q->qname.c);
-                break;
-            }
-        }
-    }
-    // If we cannot find in the client requests, look to see if this was
-    // started by mDNSResponder.
-    if (pid == -1)
-    {
-        for (q = mDNSStorage.Questions; q; q = q->next)
-        {
-            if (q && q->LocalSocket != NULL)
-            {
-                mDNSu16 port = mDNSPlatformGetUDPPort(q->LocalSocket);
-                if (port == srcport)
-                {
-#if APPLE_OSX_mDNSResponder
-                    pid = getpid();
-#endif // APPLE_OSX_mDNSResponder
-                    LogInfo("DNSServiceGetPID: srcport %d, pid %d [%s], question %##s", htons(srcport), pid, "_mDNSResponder", q->qname.c);
-                    break;
-                }
-            }
-        }
-    }
-        
-    pi.err = 0;
-    pi.pid = pid;
-    send_all(request->sd, (const char *)&pi, sizeof(PIDInfo));
-    LogOperation("%3d: DNSServiceGetPID STOP", request->sd);
-}
-
 // ***************************************************************************
 #if COMPILER_LIKES_PRAGMA_MARK
 #pragma mark -
@@ -4120,14 +3270,13 @@
 
 mDNSlocal void port_mapping_termination_callback(request_state *request)
 {
-    LogOperation("%3d: DNSServiceNATPortMappingCreate(%X, %u, %u, %d) STOP PID[%d](%s)", request->sd,
+	LogOperation("%3d: DNSServiceNATPortMappingCreate(%X, %u, %u, %d) STOP", request->sd,
                  DNSServiceProtocol(request->u.pm.NATinfo.Protocol),
-                 mDNSVal16(request->u.pm.NATinfo.IntPort), mDNSVal16(request->u.pm.ReqExt), request->u.pm.NATinfo.NATLease, 
-		         request->process_id, request->pid_name);
+		mDNSVal16(request->u.pm.NATinfo.IntPort), mDNSVal16(request->u.pm.ReqExt), request->u.pm.NATinfo.NATLease);
     mDNS_StopNATOperation(&mDNSStorage, &request->u.pm.NATinfo);
 }
 
-// Called via function pointer when we get a NAT Traversal (address request or port mapping) response
+// Called via function pointer when we get a NAT-PMP address request or port mapping response
 mDNSlocal void port_mapping_create_request_callback(mDNS *m, NATTraversalInfo *n)
 {
     request_state *request = (request_state *)n->clientContext;
@@ -4212,9 +3361,8 @@
     request->u.pm.NATinfo.clientCallback = port_mapping_create_request_callback;
     request->u.pm.NATinfo.clientContext  = request;
 
-    LogOperation("%3d: DNSServiceNATPortMappingCreate(%X, %u, %u, %d) START PID[%d](%s)", request->sd,
-                 protocol, mDNSVal16(request->u.pm.NATinfo.IntPort), mDNSVal16(request->u.pm.ReqExt), request->u.pm.NATinfo.NATLease, 
-		         request->process_id, request->pid_name);
+	LogOperation("%3d: DNSServiceNATPortMappingCreate(%X, %u, %u, %d) START", request->sd,
+		protocol, mDNSVal16(request->u.pm.NATinfo.IntPort), mDNSVal16(request->u.pm.ReqExt), request->u.pm.NATinfo.NATLease);
     err = mDNS_StartNATOperation(&mDNSStorage, &request->u.pm.NATinfo);
     if (err) LogMsg("ERROR: mDNS_StartNATOperation: %d", (int)err);
     else request->terminate = port_mapping_termination_callback;
@@ -4230,17 +3378,16 @@
 
 mDNSlocal void addrinfo_termination_callback(request_state *request)
 {
-    LogOperation("%3d: DNSServiceGetAddrInfo(%##s) STOP PID[%d](%s)", request->sd, request->u.addrinfo.q4.qname.c,
-		          request->process_id, request->pid_name);
+	LogOperation("%3d: DNSServiceGetAddrInfo(%##s) STOP", request->sd, request->u.addrinfo.q4.qname.c);
 
     if (request->u.addrinfo.q4.QuestionContext)
     {
         mDNS_StopQuery(&mDNSStorage, &request->u.addrinfo.q4);
-        LogMcastQ(&mDNSStorage, &request->u.addrinfo.q4, request, q_stop);
         request->u.addrinfo.q4.QuestionContext = mDNSNULL;
     }
     if (request->u.addrinfo.q4.qnameOrig)
     {
+		//freeL("QueryTermination", request->u.addrinfo.q4.qnameOrig);
         os_free(request->u.addrinfo.q4.qnameOrig);
         request->u.addrinfo.q4.qnameOrig = mDNSNULL;
     }
@@ -4250,14 +3397,15 @@
         {
             LogInfo("addrinfo_termination_callback: Stopping q42 %##s", request->u.addrinfo.q42->qname.c);
             mDNS_StopQuery(&mDNSStorage, request->u.addrinfo.q42);
-            LogMcastQ(&mDNSStorage, request->u.addrinfo.q42, request, q_stop);
         }
         if (request->u.addrinfo.q42->qnameOrig)
         {
             LogInfo("addrinfo_termination_callback: freeing q42 qnameOrig %##s", request->u.addrinfo.q42->qnameOrig->c);
+			//freeL("QueryTermination q42", request->u.addrinfo.q42->qnameOrig);
             os_free(request->u.addrinfo.q42->qnameOrig);
             request->u.addrinfo.q42->qnameOrig = mDNSNULL;
         }
+		//freeL("addrinfo Q42", request->u.addrinfo.q42);
         os_free(request->u.addrinfo.q42);
         request->u.addrinfo.q42 = mDNSNULL;
     }
@@ -4265,11 +3413,11 @@
     if (request->u.addrinfo.q6.QuestionContext)
     {
         mDNS_StopQuery(&mDNSStorage, &request->u.addrinfo.q6);
-        LogMcastQ(&mDNSStorage, &request->u.addrinfo.q6, request, q_stop);
         request->u.addrinfo.q6.QuestionContext = mDNSNULL;
     }
     if (request->u.addrinfo.q6.qnameOrig)
     {
+		//freeL("QueryTermination", request->u.addrinfo.q6.qnameOrig);
         os_free(request->u.addrinfo.q6.qnameOrig);
         request->u.addrinfo.q6.qnameOrig = mDNSNULL;
     }
@@ -4279,47 +3427,18 @@
         {
             LogInfo("addrinfo_termination_callback: Stopping q62 %##s", request->u.addrinfo.q62->qname.c);
             mDNS_StopQuery(&mDNSStorage, request->u.addrinfo.q62);
-            LogMcastQ(&mDNSStorage, request->u.addrinfo.q62, request, q_stop);
         }
         if (request->u.addrinfo.q62->qnameOrig)
         {
             LogInfo("addrinfo_termination_callback: freeing q62 qnameOrig %##s", request->u.addrinfo.q62->qnameOrig->c);
+			//freeL("QueryTermination q62", request->u.addrinfo.q62->qnameOrig);
             os_free(request->u.addrinfo.q62->qnameOrig);
             request->u.addrinfo.q62->qnameOrig = mDNSNULL;
         }
+		//freeL("addrinfo Q62", request->u.addrinfo.q62);
         os_free(request->u.addrinfo.q62);
         request->u.addrinfo.q62 = mDNSNULL;
     }
-#if APPLE_OSX_mDNSResponder
-    {
-        DNSQuestion *v4q, *v6q;
-        v4q = v6q = mDNSNULL;
-        if (request->u.addrinfo.protocol & kDNSServiceProtocol_IPv4)
-        {
-            // If we are not delivering answers, we may be timing out prematurely.
-            // Note down the current state so that we know to retry when we see a
-            // valid response again.
-            if (request->u.addrinfo.q4.TimeoutQuestion && !request->u.addrinfo.v4ans)
-            {
-                mDNSPlatformUpdateDNSStatus(&mDNSStorage, &request->u.addrinfo.q4);
-            }
-            // If we have a v4 answer and if we timed out prematurely before, provide
-            // a trigger to the upper layer so that it can retry questions if needed.
-            if (request->u.addrinfo.v4ans)
-                v4q = &request->u.addrinfo.q4;
-        }
-        if (request->u.addrinfo.protocol & kDNSServiceProtocol_IPv6)
-        {
-            if (request->u.addrinfo.q6.TimeoutQuestion && !request->u.addrinfo.v6ans)
-            {
-                mDNSPlatformUpdateDNSStatus(&mDNSStorage, &request->u.addrinfo.q6);
-            }
-            if (request->u.addrinfo.v6ans)
-                v6q = &request->u.addrinfo.q6;
-        }
-        mDNSPlatformTriggerDNSRetry(&mDNSStorage, v4q, v6q);
-    }
-#endif // APPLE_OSX_mDNSResponder
 }
 
 mDNSlocal mStatus handle_addrinfo_request(request_state *request)
@@ -4359,7 +3478,6 @@
     }
 
     request->u.addrinfo.q4.InterfaceID      = request->u.addrinfo.q6.InterfaceID      = request->u.addrinfo.interface_id;
-    request->u.addrinfo.q4.flags            = request->u.addrinfo.q6.flags            = flags;
     request->u.addrinfo.q4.Target           = request->u.addrinfo.q6.Target           = zeroAddr;
     request->u.addrinfo.q4.qname            = request->u.addrinfo.q6.qname            = d;
     request->u.addrinfo.q4.qclass           = request->u.addrinfo.q6.qclass           = kDNSServiceClass_IN;
@@ -4370,108 +3488,79 @@
     request->u.addrinfo.q4.SuppressUnusable = request->u.addrinfo.q6.SuppressUnusable = (flags & kDNSServiceFlagsSuppressUnusable   ) != 0;
     request->u.addrinfo.q4.TimeoutQuestion  = request->u.addrinfo.q6.TimeoutQuestion  = (flags & kDNSServiceFlagsTimeout            ) != 0;
     request->u.addrinfo.q4.WakeOnResolve    = request->u.addrinfo.q6.WakeOnResolve    = 0;
-    request->u.addrinfo.q4.UseBackgroundTrafficClass = request->u.addrinfo.q6.UseBackgroundTrafficClass  = (flags & kDNSServiceFlagsBackgroundTrafficClass) != 0;
-    if ((flags & kDNSServiceFlagsValidate) != 0)
-        request->u.addrinfo.q4.ValidationRequired = request->u.addrinfo.q6.ValidationRequired = DNSSEC_VALIDATION_SECURE;
-    else if ((flags & kDNSServiceFlagsValidateOptional) != 0)
-        request->u.addrinfo.q4.ValidationRequired = request->u.addrinfo.q6.ValidationRequired = DNSSEC_VALIDATION_SECURE_OPTIONAL;
-    request->u.addrinfo.q4.ValidatingResponse = request->u.addrinfo.q6.ValidatingResponse = 0;
-    request->u.addrinfo.q4.ProxyQuestion      = request->u.addrinfo.q6.ProxyQuestion      = 0;
     request->u.addrinfo.q4.qnameOrig          = request->u.addrinfo.q6.qnameOrig          = mDNSNULL;
-    request->u.addrinfo.q4.AnonInfo           = request->u.addrinfo.q6.AnonInfo           = mDNSNULL;
-
-    SetQuestionPolicy(&request->u.addrinfo.q4, request);
-    SetQuestionPolicy(&request->u.addrinfo.q6, request);
 
-    request->u.addrinfo.q4.DNSSECAuthInfo = request->u.addrinfo.q6.DNSSECAuthInfo = mDNSNULL;
-    request->u.addrinfo.q4.DAIFreeCallback = request->u.addrinfo.q6.DAIFreeCallback = mDNSNULL;
-
-    //Turn off dnssec validation for local domains
-    if (IsLocalDomain(&d))
-        request->u.addrinfo.q4.ValidationRequired = request->u.addrinfo.q6.ValidationRequired = 0;
-
-    if (request->u.addrinfo.protocol & kDNSServiceProtocol_IPv6)
+	if (request->u.addrinfo.protocol & kDNSServiceProtocol_IPv4)
     {
-        request->u.addrinfo.q6.qtype            = kDNSServiceType_AAAA;
-        request->u.addrinfo.q6.SearchListIndex  = 0;
-        // For DNSSEC questions, append search domains only if kDNSServiceFlagsValidateOptional is set
-        if ((!(request->u.addrinfo.q6.ValidationRequired == DNSSEC_VALIDATION_SECURE)) && (!(request->u.addrinfo.q6.ValidationRequired == DNSSEC_VALIDATION_INSECURE)) 
-            && hostname[strlen(hostname) - 1] != '.' && (AlwaysAppendSearchDomains || CountLabels(&d) == 1))
+		request->u.addrinfo.q4.qtype            = kDNSServiceType_A;
+		request->u.addrinfo.q4.SearchListIndex  = 0;
+
+		// We append search domains only for queries that are a single label. If overriden using
+		// command line argument "AlwaysAppendSearchDomains", then we do it for any query which
+		// is not fully qualified.
+		if (hostname[strlen(hostname) - 1] != '.' && (AlwaysAppendSearchDomains || CountLabels(&d) == 1))
         {
-            request->u.addrinfo.q6.AppendSearchDomains = 1;
-            request->u.addrinfo.q6.AppendLocalSearchDomains = 1;
+			request->u.addrinfo.q4.AppendSearchDomains = 1;
+			request->u.addrinfo.q4.AppendLocalSearchDomains = 1;
         }
         else
         {
-            request->u.addrinfo.q6.AppendSearchDomains = 0;
-            request->u.addrinfo.q6.AppendLocalSearchDomains = 0;
+			request->u.addrinfo.q4.AppendSearchDomains = 0;
+			request->u.addrinfo.q4.AppendLocalSearchDomains = 0;
         }
-        request->u.addrinfo.q6.RetryWithSearchDomains = (ApplySearchDomainsFirst(&request->u.addrinfo.q6) ? 1 : 0);
-        request->u.addrinfo.q6.QuestionCallback = queryrecord_result_callback;
-        request->u.addrinfo.q6.QuestionContext  = request;
-        err = mDNS_StartQuery(&mDNSStorage, &request->u.addrinfo.q6);
+		request->u.addrinfo.q4.RetryWithSearchDomains = (ApplySearchDomainsFirst(&request->u.addrinfo.q4) ? 1 : 0);
+		request->u.addrinfo.q4.QuestionCallback = queryrecord_result_callback;
+		request->u.addrinfo.q4.QuestionContext  = request;
+		err = mDNS_StartQuery(&mDNSStorage, &request->u.addrinfo.q4);
         if (err != mStatus_NoError)
         {
             LogMsg("ERROR: mDNS_StartQuery: %d", (int)err);
-            request->u.addrinfo.q6.QuestionContext = mDNSNULL;
+			request->u.addrinfo.q4.QuestionContext = mDNSNULL;
         }
         #if APPLE_OSX_mDNSResponder
-        err = SendAdditionalQuery(&request->u.addrinfo.q6, request, err);
+		err = SendAdditionalQuery(&request->u.addrinfo.q4, request, err);
         #endif // APPLE_OSX_mDNSResponder
-        if (!err)
-        { 
-            request->terminate = addrinfo_termination_callback;
-            LogMcastQ(&mDNSStorage, &request->u.addrinfo.q6, request, q_start);
-        }
     }
 
-    if (!err && (request->u.addrinfo.protocol & kDNSServiceProtocol_IPv4))
+	if (!err && (request->u.addrinfo.protocol & kDNSServiceProtocol_IPv6))
     {
-        request->u.addrinfo.q4.qtype            = kDNSServiceType_A;
-        request->u.addrinfo.q4.SearchListIndex  = 0;
-
-        // We append search domains only for queries that are a single label. If overriden using cmd line arg
-        // "AlwaysAppendSearchDomains", then we do it for any query which is not fully qualified.
-        // For DNSSEC questions, append search domains only if kDNSServiceFlagsValidateOptional is set.
-
-        if ((!(request->u.addrinfo.q4.ValidationRequired == DNSSEC_VALIDATION_SECURE)) && (!(request->u.addrinfo.q4.ValidationRequired == DNSSEC_VALIDATION_INSECURE)) 
-            && hostname[strlen(hostname) - 1] != '.' && (AlwaysAppendSearchDomains || CountLabels(&d) == 1))
+		request->u.addrinfo.q6.qtype            = kDNSServiceType_AAAA;
+		request->u.addrinfo.q6.SearchListIndex  = 0;
+		if (hostname[strlen(hostname) - 1] != '.' && (AlwaysAppendSearchDomains || CountLabels(&d) == 1))
         {
-            request->u.addrinfo.q4.AppendSearchDomains = 1;
-            request->u.addrinfo.q4.AppendLocalSearchDomains = 1;
+			request->u.addrinfo.q6.AppendSearchDomains = 1;
+			request->u.addrinfo.q6.AppendLocalSearchDomains = 1;
         }
         else
         {
-            request->u.addrinfo.q4.AppendSearchDomains = 0;
-            request->u.addrinfo.q4.AppendLocalSearchDomains = 0;
+			request->u.addrinfo.q6.AppendSearchDomains = 0;
+			request->u.addrinfo.q6.AppendLocalSearchDomains = 0;
         }
-        request->u.addrinfo.q4.RetryWithSearchDomains = (ApplySearchDomainsFirst(&request->u.addrinfo.q4) ? 1 : 0);
-        request->u.addrinfo.q4.QuestionCallback = queryrecord_result_callback;
-        request->u.addrinfo.q4.QuestionContext  = request;
-        err = mDNS_StartQuery(&mDNSStorage, &request->u.addrinfo.q4);
+		request->u.addrinfo.q6.RetryWithSearchDomains = (ApplySearchDomainsFirst(&request->u.addrinfo.q6) ? 1 : 0);
+		request->u.addrinfo.q6.QuestionCallback = queryrecord_result_callback;
+		request->u.addrinfo.q6.QuestionContext  = request;
+		err = mDNS_StartQuery(&mDNSStorage, &request->u.addrinfo.q6);
         if (err != mStatus_NoError)
         {
             LogMsg("ERROR: mDNS_StartQuery: %d", (int)err);
-            request->u.addrinfo.q4.QuestionContext = mDNSNULL;
-            if (request->u.addrinfo.protocol & kDNSServiceProtocol_IPv6)
-            {    
-                // If we started a query for IPv6, we need to cancel it                                                                                                           
-                mDNS_StopQuery(&mDNSStorage, &request->u.addrinfo.q6);
                 request->u.addrinfo.q6.QuestionContext = mDNSNULL;
+			if (request->u.addrinfo.protocol & kDNSServiceProtocol_IPv4)
+				{
+				// If we started a query for IPv4, we need to cancel it
+				mDNS_StopQuery(&mDNSStorage, &request->u.addrinfo.q4);
+				request->u.addrinfo.q4.QuestionContext = mDNSNULL;
             }    
         }
         #if APPLE_OSX_mDNSResponder
-        err = SendAdditionalQuery(&request->u.addrinfo.q4, request, err);
+		err = SendAdditionalQuery(&request->u.addrinfo.q6, request, err);
         #endif // APPLE_OSX_mDNSResponder
-        if (!err)
-        {
-            request->terminate = addrinfo_termination_callback;
-            LogMcastQ(&mDNSStorage, &request->u.addrinfo.q4, request, q_start);
-        }        
     }
 
-    LogOperation("%3d: DNSServiceGetAddrInfo(%X, %d, %d, %##s) START PID[%d](%s)", request->sd, flags, interfaceIndex, 
-                 request->u.addrinfo.protocol, d.c, request->process_id, request->pid_name);
+	LogOperation("%3d: DNSServiceGetAddrInfo(%X, %d, %d, %##s) START",
+		request->sd, flags, interfaceIndex, request->u.addrinfo.protocol, d.c);
+
+	if (!err) request->terminate = addrinfo_termination_callback;
+
     return(err);
 }
 
@@ -4484,12 +3573,10 @@
 mDNSlocal request_state *NewRequest(void)
 {
     request_state **p = &all_requests;
-    while (*p) 
-        p=&(*p)->next;
+	while (*p) p=&(*p)->next;
     //*p = mallocL("request_state", sizeof(request_state));
     *p = os_malloc(sizeof(request_state));
-    if (!*p) 
-        FatalError("ERROR: malloc");
+	if (!*p) FatalError("ERROR: malloc");
     mDNSPlatformMemZero(*p, sizeof(request_state));
     return(*p);
 }
@@ -4555,20 +3642,18 @@
         mDNSu32 nleft = req->hdr.datalen - req->data_bytes;
         int nread;
 #if !defined(_WIN32)
-#if 0
-        struct iovec vec = { req->msgbuf + req->data_bytes, nleft };    // Tell recvmsg where we want the bytes put
-        struct msghdr msg;
-        struct cmsghdr *cmsg;
-        char cbuf[CMSG_SPACE(4 * sizeof(dnssd_sock_t))];
-        msg.msg_name       = 0;
-        msg.msg_namelen    = 0;
-        msg.msg_iov        = &vec;
-        msg.msg_iovlen     = 1;
-        msg.msg_control    = cbuf;
-        msg.msg_controllen = sizeof(cbuf);
-        msg.msg_flags      = 0;
-        nread = recvmsg(req->sd, &msg, 0);
-#endif
+	//	struct iovec vec = { req->msgbuf + req->data_bytes, nleft };	// Tell recvmsg where we want the bytes put
+//		struct msghdr msg;
+//		struct cmsghdr *cmsg;
+//		char cbuf[CMSG_SPACE(sizeof(dnssd_sock_t))];
+		//msg.msg_name       = 0;
+		//msg.msg_namelen    = 0;
+//		msg.msg_iov        = &vec;
+	//	msg.msg_iovlen     = 1;
+	//	msg.msg_control    = cbuf;
+	//	msg.msg_controllen = sizeof(cbuf);
+	//	msg.msg_flags      = 0;
+	//	nread = recvmsg(req->sd, &msg, 0);
 		//Stanley Added 
 		nread = udsSupportReadFD(req->sd, (char *)req->msgbuf + req->data_bytes, nleft, 0, req->platform_data);
 #else
@@ -4583,14 +3668,13 @@
 //        cmsg = CMSG_FIRSTHDR(&msg);
 #if DEBUG_64BIT_SCM_RIGHTS
         LogMsg("%3d: Expecting %d %d %d %d", req->sd, sizeof(cbuf),       sizeof(cbuf),   SOL_SOCKET,       SCM_RIGHTS);
-//        LogMsg("%3d: Got       %d %d %d %d", req->sd, msg.msg_controllen, cmsg->cmsg_len, cmsg->cmsg_level, cmsg->cmsg_type);
-#endif // DEBUG_64BIT_SCM_RIGHTS
-#if 0
-        if (msg.msg_controllen != 0 &&
-            cmsg->cmsg_level   == SOL_SOCKET &&
-            cmsg->cmsg_type    == SCM_RIGHTS)
-        {
-#endif
+//		LogMsg("%3d: Got       %d %d %d %d", req->sd, msg.msg_controllen, cmsg->cmsg_len, cmsg->cmsg_level, cmsg->cmsg_type);
+#endif // DEBUG_64BIT_SCM_RIGHTS
+	//	if (msg.msg_controllen == sizeof(cbuf) &&
+	//		cmsg->cmsg_len     == CMSG_LEN(sizeof(dnssd_sock_t)) &&
+	//		cmsg->cmsg_level   == SOL_SOCKET   &&
+	//		cmsg->cmsg_type    == SCM_RIGHTS)
+	//		{
 #if APPLE_OSX_mDNSResponder
             // Strictly speaking BPF_fd belongs solely in the platform support layer, but because
             // of privilege separation on Mac OS X we need to get BPF_fd from mDNSResponderHelper,
@@ -4598,7 +3682,7 @@
             if (req->hdr.op == send_bpf)
             {
                 dnssd_sock_t x = *(dnssd_sock_t *)CMSG_DATA(cmsg);
-                LogOperation("%3d: Got len %d, BPF %d", req->sd, cmsg->cmsg_len, x);
+				LogOperation("%3d: Got BPF %d", req->sd, x);
                 mDNSPlatformReceiveBPF_fd(&mDNSStorage, x);
             }
             else
@@ -4609,8 +3693,8 @@
 #endif // DEBUG_64BIT_SCM_RIGHTS
             if (req->data_bytes < req->hdr.datalen)
             {
-                LogMsg("%3d: Client(PID [%d](%s)) sent error socket %d via SCM_RIGHTS with req->data_bytes %d < req->hdr.datalen %d",
-                       req->sd, req->process_id, req->pid_name, req->errsd, req->data_bytes, req->hdr.datalen);
+				LogMsg("%3d: Client sent error socket %d via SCM_RIGHTS with req->data_bytes %d < req->hdr.datalen %d",
+					req->sd, req->errsd, req->data_bytes, req->hdr.datalen);
                 req->ts = t_error;
                 return;
             }
@@ -4651,12 +3735,7 @@
 #endif
 
             req->errsd = socket(AF_DNSSD, SOCK_STREAM, 0);
-            if (!dnssd_SocketValid(req->errsd)) 
-            { 
-                my_throttled_perror("ERROR: socket");
-                req->ts = t_error;
-                return;
-            }
+			if (!dnssd_SocketValid(req->errsd)) { my_perror("ERROR: socket"); req->ts = t_error; return; }
 
             if (connect(req->errsd, (struct sockaddr *)&cliaddr, sizeof(cliaddr)) < 0)
             {
@@ -4718,23 +3797,13 @@
     for (;;)
     {
         read_msg(req);
-        if (req->ts == t_morecoming) 
-            return;
-        if (req->ts == t_terminated || req->ts == t_error) 
-        { 
-            AbortUnlinkAndFree(req); 
-            return; 
-        }
-        if (req->ts != t_complete) 
-        { 
-            LogMsg("request_callback: req->ts %d != t_complete PID[%d][%s]", req->ts, req->process_id, req->pid_name); 
-            AbortUnlinkAndFree(req); 
-            return; 
-        }
+		if (req->ts == t_morecoming) return;
+		if (req->ts == t_terminated || req->ts == t_error) { AbortUnlinkAndFree(req); return; }
+		if (req->ts != t_complete) { LogMsg("req->ts %d != t_complete", req->ts); AbortUnlinkAndFree(req); return; }
+
         if (req->hdr.version != VERSION)
         {
-            LogMsg("request_callback: ERROR: client IPC version %d incompatible with daemon IPC version %d PID[%d][%s]", 
-                   req->hdr.version, VERSION, req->process_id, req->pid_name);
+			LogMsg("ERROR: client version %d incompatible with daemon version %d", req->hdr.version, VERSION);
             AbortUnlinkAndFree(req);
             return;
         }
@@ -4742,7 +3811,6 @@
         switch(req->hdr.op)            //          Interface       + other data
         {
             case connection_request:       min_size = 0;                                                                           break;
-            case connection_delegate_request: min_size = 4; /* pid */                                                              break;
             case reg_service_request:      min_size += sizeof(mDNSu32) + 4 /* name, type, domain, host */ + 4 /* port, textlen */; break;
             case add_record_request:       min_size +=                   4 /* type, rdlen */              + 4 /* ttl */;           break;
             case update_record_request:    min_size +=                   2 /* rdlen */                    + 4 /* ttl */;           break;
@@ -4755,31 +3823,18 @@
             case reconfirm_record_request: min_size += sizeof(mDNSu32) + 1 /* name */ + 6 /* type, class, rdlen */;                break;
             case setdomain_request:        min_size +=                   1 /* domain */;                                           break;
             case getproperty_request:      min_size = 2;                                                                           break;
-            case getpid_request:           min_size = 2;                                                                           break;
             case port_mapping_request:     min_size += sizeof(mDNSu32) + 4 /* udp/tcp */ + 4 /* int/ext port */    + 4 /* ttl */;  break;
             case addrinfo_request:         min_size += sizeof(mDNSu32) + 4 /* v4/v6 */   + 1 /* hostname */;                       break;
             case send_bpf:                 // Same as cancel_request below
             case cancel_request:           min_size = 0;                                                                           break;
-            case release_request:          min_size += sizeof(mDNSu32) + 3 /* type, type, domain */;                               break;
-            default: LogMsg("request_callback: ERROR: validate_message - unsupported req type: %d PID[%d][%s]", 
-                            req->hdr.op, req->process_id, req->pid_name); 
-                     min_size = -1;                                                                                                break;
+			default: LogMsg("ERROR: validate_message - unsupported req type: %d", req->hdr.op); min_size = -1;                     break;
         }
 
         if ((mDNSs32)req->data_bytes < min_size)
-        { 
-            LogMsg("request_callback: Invalid message %d bytes; min for %d is %d PID[%d][%s]", 
-                    req->data_bytes, req->hdr.op, min_size, req->process_id, req->pid_name); 
-            AbortUnlinkAndFree(req); 
-            return; 
-        }
+			{ LogMsg("Invalid message %d bytes; min for %d is %d", req->data_bytes, req->hdr.op, min_size); AbortUnlinkAndFree(req); return; }
+
         if (LightweightOp(req->hdr.op) && !req->terminate)
-        { 
-            LogMsg("request_callback: Reg/Add/Update/Remove %d require existing connection PID[%d][%s]", 
-                    req->hdr.op, req->process_id, req->pid_name);                  
-            AbortUnlinkAndFree(req); 
-            return; 
-        }
+			{ LogMsg("Reg/Add/Update/Remove %d require existing connection", req->hdr.op);                  AbortUnlinkAndFree(req); return; }
 
         // check if client wants silent operation
         if (req->hdr.ipc_flags & IPC_FLAGS_NOREPLY) req->no_reply = 1;
@@ -4796,28 +3851,6 @@
             newreq->msgbuf  = req->msgbuf;
             newreq->msgptr  = req->msgptr;
             newreq->msgend  = req->msgend;
-            // if the parent request is a delegate connection, copy the
-            // relevant bits
-            if (req->validUUID)
-            {
-                int i;
-                newreq->validUUID = mDNStrue;
-                for (i = 0; i < UUID_SIZE; i++)
-                {
-                    newreq->uuid[i] = req->uuid[i];
-                }
-            }
-            else
-            {
-                if (req->process_id)
-                {
-                    newreq->process_id = req->process_id;
-                }
-                else
-                {
-                    set_peer_pid(newreq);
-                }
-            }
             req = newreq;
         }
 
@@ -4827,22 +3860,11 @@
         {
             err = mStatus_ServiceNotRunning;
         }
-        else
-        { 
-            switch(req->hdr.op)
+		else switch(req->hdr.op)
             {
                 // These are all operations that have their own first-class request_state object
-                case connection_request:
-                            LogOperation("%3d: DNSServiceCreateConnection START PID[%d](%s)",
-                                req->sd, req->process_id, req->pid_name);
-                            req->terminate = connection_termination;
-                            break;
-                case connection_delegate_request:
-                            LogOperation("%3d: DNSServiceCreateDelegateConnection START PID[%d](%s)",
-                                req->sd, req->process_id, req->pid_name);
-                            req->terminate = connection_termination;
-                            handle_connection_delegate_request(req);
-                            break;
+			case connection_request:           LogOperation("%3d: DNSServiceCreateConnection START", req->sd);
+											   req->terminate = connection_termination; break;
                 case resolve_request:              err = handle_resolve_request     (req);  break;
                 case query_request:                err = handle_queryrecord_request (req);  break;
                 case browse_request:               err = handle_browse_request      (req);  break;
@@ -4851,7 +3873,6 @@
                 case reconfirm_record_request:     err = handle_reconfirm_request   (req);  break;
                 case setdomain_request:            err = handle_setdomain_request   (req);  break;
                 case getproperty_request:                handle_getproperty_request (req);  break;
-                case getpid_request:                     handle_getpid_request      (req);  break;
                 case port_mapping_request:         err = handle_port_mapping_request(req);  break;
                 case addrinfo_request:             err = handle_addrinfo_request    (req);  break;
                 case send_bpf:                     /* Do nothing for send_bpf */            break;
@@ -4862,17 +3883,16 @@
                 case update_record_request:        err = handle_update_request      (req);  break;
                 case remove_record_request:        err = handle_removerecord_request(req);  break;
                 case cancel_request:                     handle_cancel_request      (req);  break;
-                case release_request:              err = handle_release_request     (req);  break;
-                default: LogMsg("request_callback: %3d:ERROR: Unsupported UDS req:%d PID[%d][%s]", 
-                                req->sd, req->hdr.op, req->process_id, req->pid_name);      break;
-            }
+			default: LogMsg("%3d: ERROR: Unsupported UDS req: %d", req->sd, req->hdr.op);
         }
+
         // req->msgbuf may be NULL, e.g. for connection_request or remove_record_request
+		//if (req->msgbuf) freeL("request_state msgbuf", req->msgbuf);
         if (req->msgbuf) os_free(req->msgbuf);
 
         // There's no return data for a cancel request (DNSServiceRefDeallocate returns no result)
         // For a DNSServiceGetProperty call, the handler already generated the response, so no need to do it again here
-        if (req->hdr.op != cancel_request && req->hdr.op != getproperty_request && req->hdr.op != send_bpf && req->hdr.op != getpid_request)
+		if (req->hdr.op != cancel_request && req->hdr.op != getproperty_request && req->hdr.op != send_bpf)
         {
             const mStatus err_netorder = dnssd_htonl(err);
             send_all(req->errsd, (const char *)&err_netorder, sizeof(err_netorder));
@@ -4912,8 +3932,7 @@
 
     if (!dnssd_SocketValid(sd))
     {
-        if (dnssd_errno != dnssd_EWOULDBLOCK) 
-            my_throttled_perror("ERROR: accept");
+		if (dnssd_errno != dnssd_EWOULDBLOCK) my_perror("ERROR: accept");
         return;
     }
 
@@ -4939,7 +3958,6 @@
         request->ts    = t_morecoming;
         request->sd    = sd;
         request->errsd = sd;
-        set_peer_pid(request);
 #if APPLE_OSX_mDNSResponder
         struct xucred x;
         socklen_t xucredlen = sizeof(x);
@@ -4972,14 +3990,13 @@
 #endif
     {
         my_perror("ERROR: could not set listen socket to non-blocking mode");
+		printf("uds_socket_setup: listen socket id %d non-blocking mode failed\n", skt);
         return mDNSfalse;
     }
 
     if (listen(skt, LISTENQ) != 0)
     {
         my_perror("ERROR: could not listen on listen socket");
-		printf("uds_socket_setup: listen socket id %d non-blocking mode failed\n", skt);
-
         return mDNSfalse;
     }
 
@@ -4988,11 +4005,8 @@
         my_perror("ERROR: could not add listen socket to event loop");
         return mDNSfalse;
     }
-    else
-    { 
-        LogMsg("%3d: Listening for incoming Unix Domain Socket client requests", skt);
-        mDNSStorage.uds_listener_skt = skt;
-    }
+	else LogOperation("%3d: Listening for incoming Unix Domain Socket client requests", skt);
+	
     return mDNStrue;
 }
 
@@ -5002,8 +4016,7 @@
     int ret;
     mDNSu32 i = 0;
 
-    LogInfo("udsserver_init: %d %d", _DNS_SD_H, mDNSStorage.mDNS_plat);
-
+	LogInfo("udsserver_init");
     // If a particular platform wants to opt out of having a PID file, define PID_FILE to be ""
     if (PID_FILE[0])
     {
@@ -5054,14 +4067,12 @@
             // determine whether sa_len is defined on a particular platform.
 //            laddr.sun_len = sizeof(struct sockaddr_un);
             #endif
-#if 0
-            if (strlen(MDNS_UDS_SERVERPATH) >= sizeof(laddr.sun_path))
-            {
-                LogMsg("ERROR: MDNS_UDS_SERVERPATH must be < %d characters", (int)sizeof(laddr.sun_path));
-                goto error;
-            }
-            mDNSPlatformStrCopy(laddr.sun_path, MDNS_UDS_SERVERPATH);
-#endif
+//			if (strlen(MDNS_UDS_SERVERPATH) >= sizeof(laddr.sun_path))
+//				{
+//					LogMsg("ERROR: MDNS_UDS_SERVERPATH must be < %d characters", (int)sizeof(laddr.sun_path));
+//					goto error;
+//				}
+//			mDNSPlatformStrCopy(laddr.sun_path, MDNS_UDS_SERVERPATH);
             ret = bind(listenfd, (struct sockaddr *) &laddr, sizeof(laddr));
             umask(mask);
             if (ret < 0)
@@ -5083,34 +4094,29 @@
 
         // Due to bugs in OS X (<rdar://problem/2941095>, <rdar://problem/3342704>, <rdar://problem/3839173>)
         // you have to get and set rlimits once before getrlimit will return sensible values
-#if 0
-        if (getrlimit(RLIMIT_NOFILE, &maxfds) < 0) { my_perror("ERROR: Unable to get file descriptor limit"); return 0; }
-        if (setrlimit(RLIMIT_NOFILE, &maxfds) < 0) my_perror("ERROR: Unable to set maximum file descriptor limit");
+	//if (getrlimit(RLIMIT_NOFILE, &maxfds) < 0) { my_perror("ERROR: Unable to get file descriptor limit"); return 0; }
+	//if (setrlimit(RLIMIT_NOFILE, &maxfds) < 0) my_perror("ERROR: Unable to set maximum file descriptor limit");
 
-        if (getrlimit(RLIMIT_NOFILE, &maxfds) < 0) { my_perror("ERROR: Unable to get file descriptor limit"); return 0; }
-        newfds.rlim_max = (maxfds.rlim_max > MIN_OPENFILES) ? maxfds.rlim_max : MIN_OPENFILES;
-        newfds.rlim_cur = (maxfds.rlim_cur > MIN_OPENFILES) ? maxfds.rlim_cur : MIN_OPENFILES;
-        if (newfds.rlim_max != maxfds.rlim_max || newfds.rlim_cur != maxfds.rlim_cur)
-            if (setrlimit(RLIMIT_NOFILE, &newfds) < 0) my_perror("ERROR: Unable to set maximum file descriptor limit");
-
-        if (getrlimit(RLIMIT_NOFILE, &maxfds) < 0) { my_perror("ERROR: Unable to get file descriptor limit"); return 0; }
-        debugf("maxfds.rlim_max %d", (long)maxfds.rlim_max);
-        debugf("maxfds.rlim_cur %d", (long)maxfds.rlim_cur);
-#endif
+//	if (getrlimit(RLIMIT_NOFILE, &maxfds) < 0) { my_perror("ERROR: Unable to get file descriptor limit"); return 0; }
+//	newfds.rlim_max = (maxfds.rlim_max > MIN_OPENFILES) ? maxfds.rlim_max : MIN_OPENFILES;
+//	newfds.rlim_cur = (maxfds.rlim_cur > MIN_OPENFILES) ? maxfds.rlim_cur : MIN_OPENFILES;
+//	if (newfds.rlim_max != maxfds.rlim_max || newfds.rlim_cur != maxfds.rlim_cur)
+//		if (setrlimit(RLIMIT_NOFILE, &newfds) < 0) my_perror("ERROR: Unable to set maximum file descriptor limit");
+
+//	if (getrlimit(RLIMIT_NOFILE, &maxfds) < 0) { my_perror("ERROR: Unable to get file descriptor limit"); return 0; }
+//	debugf("maxfds.rlim_max %d", (long)maxfds.rlim_max);
+//	debugf("maxfds.rlim_cur %d", (long)maxfds.rlim_cur);
     }
 #endif
-
     // We start a "LocalOnly" query looking for Automatic Browse Domain records.
     // When Domain Enumeration in uDNS.c finds an "lb" record from the network, its "FoundDomain" routine
     // creates a "LocalOnly" record, which results in our AutomaticBrowseDomainChange callback being invoked
     mDNS_GetDomains(&mDNSStorage, &mDNSStorage.AutomaticBrowseDomainQ, mDNS_DomainTypeBrowseAutomatic,
                     mDNSNULL, mDNSInterface_LocalOnly, AutomaticBrowseDomainChange, mDNSNULL);
-
     // Add "local" as recommended registration domain ("dns-sd -E"), recommended browsing domain ("dns-sd -F"), and automatic browsing domain
     RegisterLocalOnlyDomainEnumPTR(&mDNSStorage, &localdomain, mDNS_DomainTypeRegistration);
     RegisterLocalOnlyDomainEnumPTR(&mDNSStorage, &localdomain, mDNS_DomainTypeBrowse);
     AddAutoBrowseDomain(0, &localdomain);
-
     udsserver_handle_configchange(&mDNSStorage);
     return 0;
 
@@ -5153,13 +4159,15 @@
     return 0;
 }
 
-mDNSlocal void LogClientInfo(mDNS *const m, request_state *req)
+mDNSlocal void LogClientInfo(mDNS *const m, const request_state *req)
 {
     char prefix[16];
-    if (req->primary) 
-        mDNS_snprintf(prefix, sizeof(prefix), " -> ");
-    else 
-        mDNS_snprintf(prefix, sizeof(prefix), "%3d:", req->sd);
+	if (req->primary) mDNS_snprintf(prefix, sizeof(prefix), " -> ");
+	else mDNS_snprintf(prefix, sizeof(prefix), "%3d:", req->sd);
+
+	//usleep((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 3333 : 1000);
+	delay_ms((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 4 : 1);
+	
 
     if (!req->terminate)
         LogMsgNoIdent("%s No operation yet on this socket", prefix);
@@ -5167,200 +4175,56 @@
     {
         int num_records = 0, num_ops = 0;
         const registered_record_entry *p;
-        request_state *r;
+		const request_state *r;
         for (p = req->u.reg_recs; p; p=p->next) num_records++;
         for (r = req->next; r; r=r->next) if (r->primary == req) num_ops++;
-        LogMsgNoIdent("%s DNSServiceCreateConnection: %d registered record%s, %d kDNSServiceFlagsShareConnection operation%s PID[%d](%s)", 
-		               prefix, num_records, num_records != 1 ? "s" : "", num_ops,     num_ops     != 1 ? "s" : "", 
-                       req->process_id, req->pid_name);
+		LogMsgNoIdent("%s DNSServiceCreateConnection: %d registered record%s, %d kDNSServiceFlagsShareConnection operation%s", prefix,
+			num_records, num_records != 1 ? "s" : "",
+			num_ops,     num_ops     != 1 ? "s" : "");
         for (p = req->u.reg_recs; p; p=p->next)
-            LogMsgNoIdent(" ->  DNSServiceRegisterRecord %3d %s PID[%d](%s)", p->key, ARDisplayString(m, p->rr), 
-                          req->process_id, req->pid_name);
+			LogMsgNoIdent(" ->  DNSServiceRegisterRecord %3d %s", p->key, ARDisplayString(m, p->rr));
         for (r = req->next; r; r=r->next) if (r->primary == req) LogClientInfo(m, r);
     }
     else if (req->terminate == regservice_termination_callback)
     {
         service_instance *ptr;
-        //char anonstr[256];
-        char anonstr[64];
         for (ptr = req->u.servicereg.instances; ptr; ptr = ptr->next)
-            LogMsgNoIdent("%s DNSServiceRegister         %##s%s %u/%u PID[%d](%s)",
-                    (ptr == req->u.servicereg.instances) ? prefix : "    ", ptr->srs.RR_SRV.resrec.name->c,
-                    AnonDataToString(ptr->srs.AnonData, 0, anonstr, sizeof(anonstr)), mDNSVal16(req->u.servicereg.port),
-                    SRS_PORT(&ptr->srs), req->process_id, req->pid_name);
+			LogMsgNoIdent("%s DNSServiceRegister         %##s %u/%u",
+				(ptr == req->u.servicereg.instances) ? prefix : "    ",
+				ptr->srs.RR_SRV.resrec.name->c, mDNSVal16(req->u.servicereg.port), SRS_PORT(&ptr->srs));
     }
     else if (req->terminate == browse_termination_callback)
     {
         browser_t *blist;
-        //char anonstr[256];
-        char anonstr[64];
         for (blist = req->u.browser.browsers; blist; blist = blist->next)
-            LogMsgNoIdent("%s DNSServiceBrowse           %##s%s PID[%d](%s)", 
-		    (blist == req->u.browser.browsers) ? prefix : "    ",blist->q.qname.c,
-            AnonDataToString(req->u.browser.AnonData, 0, anonstr, sizeof(anonstr)), req->process_id, req->pid_name);
+			LogMsgNoIdent("%s DNSServiceBrowse           %##s", (blist == req->u.browser.browsers) ? prefix : "    ", blist->q.qname.c);
     }
     else if (req->terminate == resolve_termination_callback)
-        LogMsgNoIdent("%s DNSServiceResolve          %##s PID[%d](%s)", 
-		prefix, req->u.resolve.qsrv.qname.c, req->process_id, req->pid_name);
+		LogMsgNoIdent("%s DNSServiceResolve          %##s", prefix, req->u.resolve.qsrv.qname.c);
     else if (req->terminate == queryrecord_termination_callback)
-        LogMsgNoIdent("%s DNSServiceQueryRecord      %##s (%s) PID[%d](%s)", 
-		prefix, req->u.queryrecord.q.qname.c, DNSTypeName(req->u.queryrecord.q.qtype), req->process_id, req->pid_name);
+		LogMsgNoIdent("%s DNSServiceQueryRecord      %##s (%s)", prefix, req->u.queryrecord.q.qname.c, DNSTypeName(req->u.queryrecord.q.qtype));
     else if (req->terminate == enum_termination_callback)
-        LogMsgNoIdent("%s DNSServiceEnumerateDomains %##s PID[%d](%s)", prefix, req->u.enumeration.q_all.qname.c, 
-                       req->process_id, req->pid_name);
+		LogMsgNoIdent("%s DNSServiceEnumerateDomains %##s", prefix, req->u.enumeration.q_all.qname.c);
     else if (req->terminate == port_mapping_termination_callback)
-        LogMsgNoIdent("%s DNSServiceNATPortMapping   %s%s Int %5d Req %5d Ext %.4a:%5d Req TTL %5d Granted TTL %5d PID[%d](%s)",
+		LogMsgNoIdent("%s DNSServiceNATPortMapping   %.4a %s%s Int %d Req %d Ext %d Req TTL %d Granted TTL %d",
                       prefix,
+			&req->u.pm.NATinfo.ExternalAddress,
                       req->u.pm.NATinfo.Protocol & NATOp_MapTCP ? "TCP" : "   ",
                       req->u.pm.NATinfo.Protocol & NATOp_MapUDP ? "UDP" : "   ",
                       mDNSVal16(req->u.pm.NATinfo.IntPort),
                       mDNSVal16(req->u.pm.ReqExt),
-                      &req->u.pm.NATinfo.ExternalAddress,
                       mDNSVal16(req->u.pm.NATinfo.ExternalPort),
                       req->u.pm.NATinfo.NATLease,
-                      req->u.pm.NATinfo.Lifetime,
-		              req->process_id, req->pid_name);
+			req->u.pm.NATinfo.Lifetime);
     else if (req->terminate == addrinfo_termination_callback)
-        LogMsgNoIdent("%s DNSServiceGetAddrInfo      %s%s %##s PID[%d](%s)", prefix,
+		LogMsgNoIdent("%s DNSServiceGetAddrInfo      %s%s %##s", prefix,
                       req->u.addrinfo.protocol & kDNSServiceProtocol_IPv4 ? "v4" : "  ",
                       req->u.addrinfo.protocol & kDNSServiceProtocol_IPv6 ? "v6" : "  ",
-                      req->u.addrinfo.q4.qname.c, req->process_id, req->pid_name);
+			req->u.addrinfo.q4.qname.c);
     else
         LogMsgNoIdent("%s Unrecognized operation %p", prefix, req->terminate);
 }
 
-mDNSlocal void GetMcastClients(request_state *req)
-{
-    if (req->terminate == connection_termination)
-    {
-        int num_records = 0, num_ops = 0;
-        const registered_record_entry *p;
-        request_state *r;
-        for (p = req->u.reg_recs; p; p=p->next) 
-            num_records++;
-        for (r = req->next; r; r=r->next) 
-            if (r->primary == req) 
-                num_ops++;
-        for (p = req->u.reg_recs; p; p=p->next)
-        {
-            if (!AuthRecord_uDNS(p->rr))
-                n_mrecords++;
-        }
-        for (r = req->next; r; r=r->next) 
-            if (r->primary == req) 
-                GetMcastClients(r);
-    }
-    else if (req->terminate == regservice_termination_callback)
-    {
-        service_instance *ptr;
-        for (ptr = req->u.servicereg.instances; ptr; ptr = ptr->next)
-        {
-            if (!AuthRecord_uDNS(&ptr->srs.RR_SRV))
-                n_mrecords++; 
-        }
-    }
-    else if (req->terminate == browse_termination_callback)
-    {
-        browser_t *blist;
-        for (blist = req->u.browser.browsers; blist; blist = blist->next)
-        {
-            if (mDNSOpaque16IsZero(blist->q.TargetQID))
-                n_mquests++;
-        }
-    }
-    else if (req->terminate == resolve_termination_callback)
-    {
-        if ((mDNSOpaque16IsZero(req->u.resolve.qsrv.TargetQID)) && (req->u.resolve.qsrv.ThisQInterval > 0))
-            n_mquests++;
-    }
-    else if (req->terminate == queryrecord_termination_callback)
-    {
-        if ((mDNSOpaque16IsZero(req->u.queryrecord.q.TargetQID)) && (req->u.queryrecord.q.ThisQInterval > 0))
-            n_mquests++;
-    }
-    else if (req->terminate == addrinfo_termination_callback)
-    {
-        if ((mDNSOpaque16IsZero(req->u.addrinfo.q4.TargetQID)) && (req->u.addrinfo.q4.ThisQInterval > 0))
-            n_mquests++;
-    }
-    else
-    {
-        return;
-    }
-}
-
-
-mDNSlocal void LogMcastClientInfo(request_state *req)
-{
-    if (!req->terminate)
-        LogMcastNoIdent("No operation yet on this socket");
-    else if (req->terminate == connection_termination)
-    {
-        int num_records = 0, num_ops = 0;
-        const registered_record_entry *p;
-        request_state *r;
-        for (p = req->u.reg_recs; p; p=p->next) 
-            num_records++;
-        for (r = req->next; r; r=r->next) 
-            if (r->primary == req) 
-                num_ops++;
-        for (p = req->u.reg_recs; p; p=p->next)
-        {
-            if (!AuthRecord_uDNS(p->rr))
-                LogMcastNoIdent("R: ->  DNSServiceRegisterRecord:  %##s %s PID[%d](%s)", p->rr->resrec.name->c, 
-                                DNSTypeName(p->rr->resrec.rrtype), req->process_id, req->pid_name, i_mcount++);
-        }
-        for (r = req->next; r; r=r->next) 
-            if (r->primary == req) 
-                LogMcastClientInfo(r);
-    }
-    else if (req->terminate == regservice_termination_callback)
-    {
-        service_instance *ptr;
-        for (ptr = req->u.servicereg.instances; ptr; ptr = ptr->next)
-        {
-            if (!AuthRecord_uDNS(&ptr->srs.RR_SRV)) 
-                LogMcastNoIdent("R: DNSServiceRegister:  %##s %u/%u PID[%d](%s)", ptr->srs.RR_SRV.resrec.name->c, mDNSVal16(req->u.servicereg.port), 
-                                SRS_PORT(&ptr->srs), req->process_id, req->pid_name, i_mcount++);
-        }
-    }
-    else if (req->terminate == browse_termination_callback)
-    {
-        browser_t *blist;
-        for (blist = req->u.browser.browsers; blist; blist = blist->next)
-        {
-            if (mDNSOpaque16IsZero(blist->q.TargetQID))
-                LogMcastNoIdent("Q: DNSServiceBrowse  %##s %s PID[%d](%s)", blist->q.qname.c, DNSTypeName(blist->q.qtype),
-                                req->process_id, req->pid_name, i_mcount++);
-        }
-    }
-    else if (req->terminate == resolve_termination_callback)
-    {
-        if ((mDNSOpaque16IsZero(req->u.resolve.qsrv.TargetQID)) && (req->u.resolve.qsrv.ThisQInterval > 0))
-            LogMcastNoIdent("Q: DNSServiceResolve  %##s %s PID[%d](%s)", req->u.resolve.qsrv.qname.c, DNSTypeName(req->u.resolve.qsrv.qtype),
-                            req->process_id, req->pid_name, i_mcount++);
-    }
-    else if (req->terminate == queryrecord_termination_callback)
-    {
-        if ((mDNSOpaque16IsZero(req->u.queryrecord.q.TargetQID)) && (req->u.queryrecord.q.ThisQInterval > 0))
-            LogMcastNoIdent("Q: DNSServiceQueryRecord  %##s %s PID[%d](%s)", req->u.queryrecord.q.qname.c, DNSTypeName(req->u.queryrecord.q.qtype), 
-                          req->process_id, req->pid_name, i_mcount++);
-    }
-    else if (req->terminate == addrinfo_termination_callback)
-    {
-        if ((mDNSOpaque16IsZero(req->u.addrinfo.q4.TargetQID)) && (req->u.addrinfo.q4.ThisQInterval > 0))
-            LogMcastNoIdent("Q: DNSServiceGetAddrInfo  %s%s %##s PID[%d](%s)",
-                          req->u.addrinfo.protocol & kDNSServiceProtocol_IPv4 ? "v4" : "  ",
-                          req->u.addrinfo.protocol & kDNSServiceProtocol_IPv6 ? "v6" : "  ",
-                          req->u.addrinfo.q4.qname.c, req->process_id, req->pid_name, i_mcount++);
-    }
-    else
-    {
-        return;
-    }
-    
-}
-
 mDNSlocal char *RecordTypeName(mDNSu8 rtype)
 {
     switch (rtype)
@@ -5407,6 +4271,8 @@
                         LogMsgNoIdent(" %s   %u  %s", RecordTypeName(ar->resrec.RecordType), scopeid, ARDisplayString(m, ar));
                     }
                 }
+				//usleep((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 3333 : 1000);
+				delay_ms((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 4 : 1);
             }
     }
 
@@ -5434,45 +4300,14 @@
                     LogMsgNoIdent(" %s   LO %s", RecordTypeName(ar->resrec.RecordType), ARDisplayString(m, ar));
                 else if (ar->ARType == AuthRecordP2P)
                     LogMsgNoIdent(" %s   PP %s", RecordTypeName(ar->resrec.RecordType), ARDisplayString(m, ar));
+				//usleep((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 3333 : 1000);
+				delay_ms((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 4 : 1);
             }
     }
 
     if (showheader) LogMsgNoIdent("<None>");
 }
 
-mDNSlocal char *AnonInfoToString(AnonymousInfo *ai, char *anonstr, int anstrlen)
-{
-    anonstr[0] = 0;
-    if (ai && ai->AnonData)
-    {
-        return (AnonDataToString(ai->AnonData, ai->AnonDataLen, anonstr, anstrlen));
-    }
-    return anonstr;
-}
-
-mDNSlocal void LogOneAuthRecord(mDNS *const m, const AuthRecord *ar, mDNSs32 now, const char *const ifname)
-{
-    //char anstr[256];
-    char anstr[64];
-    if (AuthRecord_uDNS(ar))
-    {
-        LogMsgNoIdent("%7d %7d %7d %7d %s",
-                      ar->ThisAPInterval / mDNSPlatformOneSecond,
-                      (ar->LastAPTime + ar->ThisAPInterval - now) / mDNSPlatformOneSecond,
-                      ar->expire ? (ar->expire - now) / mDNSPlatformOneSecond : 0,
-                      ar->state, ARDisplayString(m, ar));
-    }
-    else
-    {
-        LogMsgNoIdent("%7d %7d %7d %7s %s%s",
-                      ar->ThisAPInterval / mDNSPlatformOneSecond,
-                      ar->AnnounceCount ? (ar->LastAPTime + ar->ThisAPInterval - now) / mDNSPlatformOneSecond : 0,
-                      ar->TimeExpire    ? (ar->TimeExpire                      - now) / mDNSPlatformOneSecond : 0,
-                      ifname ? ifname : "ALL",
-                      ARDisplayString(m, ar), AnonInfoToString(ar->resrec.AnonInfo, anstr, sizeof(anstr)));
-    }
-}
-
 mDNSlocal void LogAuthRecords(mDNS *const m, const mDNSs32 now, AuthRecord *ResourceRecords, int *proxy)
 {
     mDNSBool showheader = mDNStrue;
@@ -5496,152 +4331,29 @@
                     LogMsgNoIdent("Proxying for %.6a seq %d",                                &owner.HMAC,                               owner.seq);
             }
             if (AuthRecord_uDNS(ar))
-            {
-                LogOneAuthRecord(m, ar, now, ifname);
-            }
+				LogMsgNoIdent("%7d %7d %7d %7d %s",
+					ar->ThisAPInterval / mDNSPlatformOneSecond,
+					(ar->LastAPTime + ar->ThisAPInterval - now) / mDNSPlatformOneSecond,
+					ar->expire ? (ar->expire - now) / mDNSPlatformOneSecond : 0,
+					ar->state, ARDisplayString(m, ar));
             else if (ar->ARType == AuthRecordLocalOnly)
-            {
                 LogMsgNoIdent("                             LO %s", ARDisplayString(m, ar));
-            }
             else if (ar->ARType == AuthRecordP2P)
-            {
                 LogMsgNoIdent("                             PP %s", ARDisplayString(m, ar));
-            }
             else
-            {
-                LogOneAuthRecord(m, ar, now, ifname);
-                if (ar->resrec.AnonInfo)
-                {
-                    ResourceRecord *nsec3 = ar->resrec.AnonInfo->nsec3RR;
-                    // We just print the values from the AuthRecord to keep it nicely aligned though
-                    // all we want here is the nsec3 information.
                     LogMsgNoIdent("%7d %7d %7d %7s %s",
                                   ar->ThisAPInterval / mDNSPlatformOneSecond,
                                   ar->AnnounceCount ? (ar->LastAPTime + ar->ThisAPInterval - now) / mDNSPlatformOneSecond : 0,
                                   ar->TimeExpire    ? (ar->TimeExpire                      - now) / mDNSPlatformOneSecond : 0,
                                   ifname ? ifname : "ALL",
-                                  RRDisplayString(m, nsec3));
-                }
-            }
+					ARDisplayString(m, ar));
+			//usleep((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 3333 : 1000);
+			delay_ms((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 4 : 1);
         }
     }
     if (showheader) LogMsgNoIdent("<None>");
 }
 
-mDNSlocal void PrintOneCacheRecord(mDNS *const m, const CacheRecord *cr, mDNSu32 slot, const mDNSu32 remain, const char *ifname, mDNSu32 *CacheUsed)
-{
-    LogMsgNoIdent("%3d %s%8d %-7s%s %-6s%s",
-                  slot,
-                  cr->CRActiveQuestion ? "*" : " ",
-                  remain,
-                  ifname ? ifname : "-U-",
-                  (cr->resrec.RecordType == kDNSRecordTypePacketNegative)  ? "-" :
-                  (cr->resrec.RecordType & kDNSRecordTypePacketUniqueMask) ? " " : "+",
-                  DNSTypeName(cr->resrec.rrtype),
-                  CRDisplayString(m, cr));
-    (*CacheUsed)++;
-}
-
-mDNSlocal void PrintCachedRecords(mDNS *const m, const CacheRecord *cr, mDNSu32 slot, const mDNSu32 remain, const char *ifname, mDNSu32 *CacheUsed)
-{
-    CacheRecord *nsec;
-    CacheRecord *soa;
-    nsec = cr->nsec;
-
-    // The records that are cached under the main cache record like nsec, soa don't have
-    // their own lifetime. If the main cache record expires, they also expire.
-    while (nsec)
-    {
-        PrintOneCacheRecord(m, nsec, slot, remain, ifname, CacheUsed);
-        nsec = nsec->next;
-    }
-    soa = cr->soa;
-    if (soa)
-    {
-        PrintOneCacheRecord(m, soa, slot, remain, ifname, CacheUsed);
-    }
-    if (cr->resrec.AnonInfo)
-    {
-        ResourceRecord *nsec3 = cr->resrec.AnonInfo->nsec3RR;
-        // Even though it is a resource record, we print the sameway
-        // as a cache record so that it aligns properly.
-        if (nsec3)
-        {
-            LogMsgNoIdent("%3d %s%8d %-7s%s %-6s%s",
-                          slot,
-                          " ",
-                          remain,
-                          ifname ? ifname : "-U-",
-                          (nsec3->RecordType == kDNSRecordTypePacketNegative)  ? "-" :
-                          (nsec3->RecordType & kDNSRecordTypePacketUniqueMask) ? " " : "+",
-                          DNSTypeName(nsec3->rrtype),
-                          RRDisplayString(m, nsec3));
-        }
-    }
-}
-
-mDNSlocal char *AnonDataToString(const mDNSu8 *ad, int adlen, char *adstr, int adstrlen)
-{
-    adstr[0] = 0;
-    if (ad)
-    {
-        int len;
-        char *orig = adstr;
-
-        // If the caller is lazy to compute the length, we do it for them.
-        if (!adlen)
-            len = strlen((const char *)ad);
-        else
-            len = adlen;
-
-        // Print the anondata within brackets. Hence, we need space for two
-        // brackets and a NULL byte.
-        if (len > (adstrlen - 3))
-            len = adstrlen - 3;
-
-        *adstr++ = '(';
-        mDNSPlatformMemCopy(adstr, ad, len);
-        adstr[len] = ')';
-        adstr[len+1] = 0;
-        return orig;
-    }
-    return adstr;
-}
-
-mDNSexport void LogMDNSStatistics(mDNS *const m)
-{
-    LogMsgNoIdent("--- MDNS Statistics ---");
-    
-    LogMsgNoIdent("Name Conflicts                 %u", m->mDNSStats.NameConflicts);
-    LogMsgNoIdent("KnownUnique Name Conflicts     %u", m->mDNSStats.KnownUniqueNameConflicts);
-    LogMsgNoIdent("Duplicate Query Suppressions   %u", m->mDNSStats.DupQuerySuppressions);
-    LogMsgNoIdent("KA Suppressions                %u", m->mDNSStats.KnownAnswerSuppressions);
-    LogMsgNoIdent("KA Multiple Packets            %u", m->mDNSStats.KnownAnswerMultiplePkts);
-    LogMsgNoIdent("Poof Cache Deletions           %u", m->mDNSStats.PoofCacheDeletions);
-    LogMsgNoIdent("--------------------------------");
-
-    LogMsgNoIdent("Multicast packets Sent         %u", m->MulticastPacketsSent);
-    LogMsgNoIdent("Multicast packets Received     %u", m->MPktNum);
-    LogMsgNoIdent("Remote Subnet packets          %u", m->RemoteSubnet);
-    LogMsgNoIdent("QU questions  received         %u", m->mDNSStats.UnicastBitInQueries);
-    LogMsgNoIdent("Normal multicast questions     %u", m->mDNSStats.NormalQueries);
-    LogMsgNoIdent("Answers for questions          %u", m->mDNSStats.MatchingAnswersForQueries);
-    LogMsgNoIdent("Unicast responses              %u", m->mDNSStats.UnicastResponses);
-    LogMsgNoIdent("Multicast responses            %u", m->mDNSStats.MulticastResponses);
-    LogMsgNoIdent("Unicast response Demotions     %u", m->mDNSStats.UnicastDemotedToMulticast);
-    LogMsgNoIdent("--------------------------------");
-
-    LogMsgNoIdent("Sleeps                         %u", m->mDNSStats.Sleeps);
-    LogMsgNoIdent("Wakeups                        %u", m->mDNSStats.Wakes);
-    LogMsgNoIdent("Interface UP events            %u", m->mDNSStats.InterfaceUp);
-    LogMsgNoIdent("Interface UP Flap events       %u", m->mDNSStats.InterfaceUpFlap);
-    LogMsgNoIdent("Interface Down events          %u", m->mDNSStats.InterfaceDown);
-    LogMsgNoIdent("Interface DownFlap events      %u", m->mDNSStats.InterfaceDownFlap);
-    LogMsgNoIdent("Cache refresh queries          %u", m->mDNSStats.CacheRefreshQueries);
-    LogMsgNoIdent("Cache refreshed                %u", m->mDNSStats.CacheRefreshed);
-    LogMsgNoIdent("Wakeup on Resolves             %u", m->mDNSStats.WakeOnResolves);
-}
-
 mDNSexport void udsserver_info(mDNS *const m)
 {
     const mDNSs32 now = mDNS_TimeNow(m);
@@ -5658,7 +4370,6 @@
     LogMsgNoIdent("------------ Cache -------------");
     LogMsgNoIdent("Slt Q     TTL if     U Type rdlen");
     for (slot = 0; slot < CACHE_HASH_SLOTS; slot++)
-    {
         for (cg = m->rrcache_hash[slot]; cg; cg=cg->next)
         {
             CacheUsed++;    // Count one cache entity for the CacheGroup object
@@ -5667,14 +4378,24 @@
                 const mDNSs32 remain = cr->resrec.rroriginalttl - (now - cr->TimeRcvd) / mDNSPlatformOneSecond;
                 const char *ifname;
                 mDNSInterfaceID InterfaceID = cr->resrec.InterfaceID;
-                if (!InterfaceID && cr->resrec.rDNSServer && cr->resrec.rDNSServer->scoped)
+				if (!InterfaceID && cr->resrec.rDNSServer)
                     InterfaceID = cr->resrec.rDNSServer->interface;
                 ifname = InterfaceNameForID(m, InterfaceID);
+				CacheUsed++;
                 if (cr->CRActiveQuestion) CacheActive++;
-                PrintOneCacheRecord(m, cr, slot, remain, ifname, &CacheUsed);
-                PrintCachedRecords(m, cr, slot, remain, ifname, &CacheUsed);
-            }
+				LogMsgNoIdent("%3d %s%8ld %-7s%s %-6s%s",
+					slot,
+					cr->CRActiveQuestion ? "*" : " ",
+					remain,
+					ifname ? ifname : "-U-",
+					(cr->resrec.RecordType == kDNSRecordTypePacketNegative)  ? "-" :
+					(cr->resrec.RecordType & kDNSRecordTypePacketUniqueMask) ? " " : "+",
+					DNSTypeName(cr->resrec.rrtype),
+					CRDisplayString(m, cr));
+				delay_ms((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 4 : 1);
+				//usleep((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 3333 : 1000);
         }
+
     }
 
     if (m->rrcache_totalused != CacheUsed)
@@ -5705,8 +4426,6 @@
     if (!m->Questions) LogMsgNoIdent("<None>");
     else
     {
-        //char anonstr[256];
-        char anonstr[64];
         CacheUsed = 0;
         CacheActive = 0;
         LogMsgNoIdent("   Int  Next if     T  NumAns VDNS    Qptr     DupOf    SU SQ Type Name");
@@ -5717,15 +4436,15 @@
             char *ifname = InterfaceNameForID(m, q->InterfaceID);
             CacheUsed++;
             if (q->ThisQInterval) CacheActive++;
-            LogMsgNoIdent("%6d%6d %-7s%s%s %5d 0x%x%x 0x%p 0x%p %1d %2d %-5s%##s%s%s",
+			LogMsgNoIdent("%6d%6d %-7s%s%s %5d 0x%x%x 0x%p 0x%p %1d %2d %-5s%##s%s",
                           i, n,
                           ifname ? ifname : mDNSOpaque16IsZero(q->TargetQID) ? "" : "-U-",
                           mDNSOpaque16IsZero(q->TargetQID) ? (q->LongLived ? "l" : " ") : (q->LongLived ? "L" : "O"),
-                          PrivateQuery(q)    ? "P" : q->ValidationRequired ? "V" : q->ValidatingResponse ? "R" : " ",
+				PrivateQuery(q)    ? "P" : " ",
                           q->CurrentAnswers, q->validDNSServers.l[1], q->validDNSServers.l[0], q, q->DuplicateOf,
-                          q->SuppressUnusable, q->SuppressQuery, DNSTypeName(q->qtype), q->qname.c,
-                          AnonInfoToString(q->AnonInfo, anonstr, sizeof(anonstr)),
-                          q->DuplicateOf ? " (dup)" : "");
+				q->SuppressUnusable, q->SuppressQuery, DNSTypeName(q->qtype), q->qname.c, q->DuplicateOf ? " (dup)" : "");
+			//usleep((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 3333 : 1000);
+			delay_ms((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 4 : 1);
         }
         LogMsgNoIdent("%lu question%s; %lu active", CacheUsed, CacheUsed > 1 ? "s" : "", CacheActive);
     }
@@ -5736,11 +4455,11 @@
             LogMsgNoIdent("                       %5d  %-6s%##s%s",
                           q->CurrentAnswers, DNSTypeName(q->qtype), q->qname.c, q->DuplicateOf ? " (dup)" : "");
 
-    LogMsgNoIdent("---- Active UDS Client Requests ----");
+	LogMsgNoIdent("---- Active Client Requests ----");
     if (!all_requests) LogMsgNoIdent("<None>");
     else
     {
-        request_state *req, *r;
+		const request_state *req, *r;
         for (req = all_requests; req; req=req->next)
         {
             if (req->primary)   // If this is a subbordinate operation, check that the parent is in the list
@@ -5755,30 +4474,25 @@
     }
 
     LogMsgNoIdent("-------- NAT Traversals --------");
-    LogMsgNoIdent("ExtAddress %.4a Retry %d Interval %d",
-                  &m->ExtAddress,
-                  m->retryGetAddr ? (m->retryGetAddr - now) / mDNSPlatformOneSecond : 0,
-                  m->retryIntervalGetAddr / mDNSPlatformOneSecond);
-    if (m->NATTraversals)
+	if (!m->NATTraversals) LogMsgNoIdent("<None>");
+	else
     {
         const NATTraversalInfo *nat;
         for (nat = m->NATTraversals; nat; nat=nat->next)
         {
-            LogMsgNoIdent("%p %s Int %5d %s Err %d Retry %5d Interval %5d Expire %5d Req %.4a:%d Ext %.4a:%d",
-                          nat,
-                          nat->Protocol ? (nat->Protocol == NATOp_MapTCP ? "TCP" : "UDP") : "ADD",
-                          mDNSVal16(nat->IntPort),
-                          (nat->lastSuccessfulProtocol == NATTProtocolNone    ? "None    " :
-                           nat->lastSuccessfulProtocol == NATTProtocolNATPMP  ? "NAT-PMP " :
-                           nat->lastSuccessfulProtocol == NATTProtocolUPNPIGD ? "UPnP/IGD" :
-                           nat->lastSuccessfulProtocol == NATTProtocolPCP     ? "PCP     " :
-                           /* else */                                           "Unknown " ),
-                          nat->Result,
+			if (nat->Protocol)
+				LogMsgNoIdent("%p %s Int %5d Ext %5d Err %d Retry %5d Interval %5d Expire %5d",
+					nat, nat->Protocol == NATOp_MapTCP ? "TCP" : "UDP",
+					mDNSVal16(nat->IntPort), mDNSVal16(nat->ExternalPort), nat->Result,
                           nat->retryPortMap ? (nat->retryPortMap - now) / mDNSPlatformOneSecond : 0,
                           nat->retryInterval / mDNSPlatformOneSecond,
-                          nat->ExpiryTime ? (nat->ExpiryTime - now) / mDNSPlatformOneSecond : 0,
-                          &nat->NewAddress, mDNSVal16(nat->RequestedPort),
-                          &nat->ExternalAddress, mDNSVal16(nat->ExternalPort));
+					nat->ExpiryTime ? (nat->ExpiryTime - now) / mDNSPlatformOneSecond : 0);
+			else
+				LogMsgNoIdent("%p Address Request               Retry %5d Interval %5d", nat,
+					(m->retryGetAddr - now) / mDNSPlatformOneSecond,
+					m->retryIntervalGetAddr / mDNSPlatformOneSecond);
+			delay_ms((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 4 : 1);
+			//usleep((m->KnownBugs & mDNS_KnownBug_LossySyslog) ? 3333 : 1000);
         }
     }
 
@@ -5788,13 +4502,7 @@
     {
         const DomainAuthInfo *a;
         for (a = m->AuthInfoList; a; a = a->next)
-        {
-            LogMsgNoIdent("%##s %##s %##s %d %d %.16a%s",
-                          a->domain.c, a->keyname.c,
-                          a->hostname.c, (a->port.b[0] << 8 | a->port.b[1]),
-                          (a->deltime ? (a->deltime - now) : 0),
-                          &a->AutoTunnelInnerAddress, a->AutoTunnel ? " AutoTunnel" : "");
-        }
+			LogMsgNoIdent("%##s %##s %##s %d %s", a->domain.c, a->keyname.c, a->hostname.c, (a->port.b[0] << 8 | a->port.b[1]), a->AutoTunnel ? a->AutoTunnel : "");
     }
 
     #if APPLE_OSX_mDNSResponder
@@ -5804,8 +4512,8 @@
     {
         const ClientTunnel *c;
         for (c = m->TunnelClients; c; c = c->next)
-            LogMsgNoIdent("%##s local %.16a %.4a %.16a remote %.16a %.4a %5d %.16a interval %d",
-                          c->dstname.c, &c->loc_inner, &c->loc_outer, &c->loc_outer6, &c->rmt_inner, &c->rmt_outer, mDNSVal16(c->rmt_outer_port), &c->rmt_outer6, c->q.ThisQInterval);
+			LogMsgNoIdent("%s %##s local %.16a %.4a %.16a remote %.16a %.4a %5d %.16a interval %d",
+				c->prefix, c->dstname.c, &c->loc_inner, &c->loc_outer, &c->loc_outer6, &c->rmt_inner, &c->rmt_outer, mDNSVal16(c->rmt_outer_port), &c->rmt_outer6, c->q.ThisQInterval);
     }
     #endif // APPLE_OSX_mDNSResponder
 
@@ -5821,9 +4529,8 @@
                   m->SleepSeqNum);
 
     if (!m->SPSSocket) LogMsgNoIdent("Not offering Sleep Proxy Service");
-#ifndef SPC_DISABLED
     else LogMsgNoIdent("Offering Sleep Proxy Service: %#s", m->SPSRecords.RR_SRV.resrec.name->c);
-#endif
+
     if (m->ProxyRecords == ProxyA + ProxyD) LogMsgNoIdent("ProxyRecords: %d + %d = %d", ProxyA, ProxyD, ProxyA + ProxyD);
     else LogMsgNoIdent("ProxyRecords: MISMATCH %d + %d = %d ≠ %d", ProxyA, ProxyD, ProxyA + ProxyD, m->ProxyRecords);
 
@@ -5845,56 +4552,6 @@
             LogMsgNoIdent("%##s %s", s->domain.c, ifname ? ifname : "");
         }
     }
-    LogInfo("--- Trust Anchors ---");
-    if (!m->TrustAnchors) 
-    {
-        LogInfo("<None>");
-    }
-    else
-    {
-        TrustAnchor *ta;
-        mDNSu8 fromTimeBuf[64];
-        mDNSu8 untilTimeBuf[64];
-
-        for (ta=m->TrustAnchors; ta; ta=ta->next)
-        {
-            mDNSPlatformFormatTime((unsigned long)ta->validFrom, fromTimeBuf, sizeof(fromTimeBuf));
-            mDNSPlatformFormatTime((unsigned long)ta->validUntil, untilTimeBuf, sizeof(untilTimeBuf));
-            LogInfo("%##s %d %d %d %d %s %s", ta->zone.c, ta->rds.keyTag,
-                ta->rds.alg, ta->rds.digestType, ta->digestLen, fromTimeBuf, untilTimeBuf);
-        }
-    }
-
-    LogInfo("--- DNSSEC Statistics ---");
-
-    LogInfo("Next Stats Time                 %u", m->NextStatLogTime - mDNSPlatformUTC());
-    LogMsgNoIdent("Unicast Cache size              %u", m->rrcache_totalused_unicast);
-    LogInfo("DNSSEC  Cache size              %u", m->DNSSECStats.TotalMemUsed);
-    if (m->rrcache_totalused_unicast)
-        LogInfo("DNSSEC  usage percentage        %u", ((unsigned long)(m->DNSSECStats.TotalMemUsed * 100))/m->rrcache_totalused_unicast);
-    LogInfo("DNSSEC  Extra Packets (0 to 2)  %u", m->DNSSECStats.ExtraPackets0);
-    LogInfo("DNSSEC  Extra Packets (3 to 6)  %u", m->DNSSECStats.ExtraPackets3);
-    LogInfo("DNSSEC  Extra Packets (7 to 9)  %u", m->DNSSECStats.ExtraPackets7);
-    LogInfo("DNSSEC  Extra Packets ( >= 10)  %u", m->DNSSECStats.ExtraPackets10);
-
-    LogInfo("DNSSEC  Latency (0 to 4ms)      %u", m->DNSSECStats.Latency0);
-    LogInfo("DNSSEC  Latency (4 to 9ms)      %u", m->DNSSECStats.Latency5);
-    LogInfo("DNSSEC  Latency (10 to 19ms)    %u", m->DNSSECStats.Latency10);
-    LogInfo("DNSSEC  Latency (20 to 49ms)    %u", m->DNSSECStats.Latency20);
-    LogInfo("DNSSEC  Latency (50 to 99ms)    %u", m->DNSSECStats.Latency50);
-    LogInfo("DNSSEC  Latency (   >=100ms)    %u", m->DNSSECStats.Latency100);
-
-    LogInfo("DNSSEC  Secure Status           %u", m->DNSSECStats.SecureStatus);
-    LogInfo("DNSSEC  Insecure Status         %u", m->DNSSECStats.InsecureStatus);
-    LogInfo("DNSSEC  Indeterminate Status    %u", m->DNSSECStats.IndeterminateStatus);
-    LogInfo("DNSSEC  Bogus Status            %u", m->DNSSECStats.BogusStatus);
-    LogInfo("DNSSEC  NoResponse Status       %u", m->DNSSECStats.NoResponseStatus);
-    LogInfo("DNSSEC  Probes sent             %u", m->DNSSECStats.NumProbesSent);
-    LogInfo("DNSSEC  Msg Size (<=1024)       %u", m->DNSSECStats.MsgSize0);
-    LogInfo("DNSSEC  Msg Size (<=2048)       %u", m->DNSSECStats.MsgSize1);
-    LogInfo("DNSSEC  Msg Size (> 2048)       %u", m->DNSSECStats.MsgSize2);
-
-    LogMDNSStatistics(m);
 
     LogMsgNoIdent("---- Task Scheduling Timers ----");
 
@@ -5918,12 +4575,9 @@
 
     LogMsgNoIdent("SPSProxyListChanged%s", m->SPSProxyListChanged ? "" : " <NONE>");
     LogMsgNoIdent("LocalRemoveEvents%s",   m->LocalRemoveEvents   ? "" : " <NONE>");
-    LogMsgNoIdent("m->AutoTunnelRelayAddr %.16a", &m->AutoTunnelRelayAddr);
-    LogMsgNoIdent("m->WABBrowseQueriesCount %d", m->WABBrowseQueriesCount);
-    LogMsgNoIdent("m->WABLBrowseQueriesCount %d", m->WABLBrowseQueriesCount);
-    LogMsgNoIdent("m->WABRegQueriesCount %d", m->WABRegQueriesCount);
-    LogMsgNoIdent("m->mDNSOppCaching %d", m->mDNSOppCaching);
-    LogMsgNoIdent("m->AutoTargetServices %d", m->AutoTargetServices);
+	LogMsgNoIdent("m->RegisterAutoTunnel6  %08X", m->RegisterAutoTunnel6);
+	LogMsgNoIdent("m->AutoTunnelRelayAddrIn  %.16a", &m->AutoTunnelRelayAddrIn);
+	LogMsgNoIdent("m->AutoTunnelRelayAddrOut  %.16a", &m->AutoTunnelRelayAddrOut);
 
 #define LogTimer(MSG,T) LogMsgNoIdent( MSG " %08X %11d  %08X %11d", (T), (T), (T)-now, (T)-now)
 
@@ -5941,7 +4595,6 @@
 
     LogTimer("m->NextCacheCheck       ", m->NextCacheCheck);
     LogTimer("m->NextScheduledSPS     ", m->NextScheduledSPS);
-    LogTimer("m->NextScheduledKA      ", m->NextScheduledKA);
     LogTimer("m->NextScheduledSPRetry ", m->NextScheduledSPRetry);
     LogTimer("m->DelaySleep           ", m->DelaySleep);
 
@@ -6071,21 +4724,21 @@
             if (r->u.resolve.ReportTime && now - r->u.resolve.ReportTime >= 0)
             {
                 r->u.resolve.ReportTime = 0;
-                LogMsgNoIdent("Client application bug PID[%d](%s) : DNSServiceResolve(%##s) active for over two minutes. "
-                              "This places considerable burden on the network.", r->process_id, r->pid_name, r->u.resolve.qsrv.qname.c);
+				LogMsgNoIdent("Client application bug: DNSServiceResolve(%##s) active for over two minutes. "
+					"This places considerable burden on the network.", r->u.resolve.qsrv.qname.c);
             }
 
         // Note: Only primary req's have reply lists, not subordinate req's.
         while (r->replies)      // Send queued replies
         {
             transfer_state result;
-            if (r->replies->next) 
-                r->replies->rhdr->flags |= dnssd_htonl(kDNSServiceFlagsMoreComing);
+			if (r->replies->next) r->replies->rhdr->flags |= dnssd_htonl(kDNSServiceFlagsMoreComing);
             result = send_msg(r);   // Returns t_morecoming if buffer full because client is not reading
             if (result == t_complete)
             {
                 reply_state *fptr = r->replies;
                 r->replies = r->replies->next;
+				//freeL("reply_state/udsserver_idle", fptr);
                 os_free(fptr);
                 r->time_blocked = 0; // reset failure counter after successful send
                 r->unresponsiveness_reports = 0;
@@ -6093,7 +4746,7 @@
             }
             else if (result == t_terminated || result == t_error)
             {
-                LogMsg("%3d: Could not write data to clientPID[%d](%s)  because of error - aborting connection", r->sd, r->process_id, r->pid_name);
+				LogMsg("%3d: Could not write data to client because of error - aborting connection", r->sd);
                 LogClientInfo(&mDNSStorage, r);
                 abort_request(r);
             }
@@ -6102,27 +4755,20 @@
 
         if (r->replies)     // If we failed to send everything, check our time_blocked timer
         {
-            if (nextevent - now > mDNSPlatformOneSecond) 
-                nextevent = now + mDNSPlatformOneSecond;
+			if (nextevent - now > mDNSPlatformOneSecond) nextevent = now + mDNSPlatformOneSecond;
 
-            if (mDNSStorage.SleepState != SleepState_Awake) 
-                r->time_blocked = 0;
-            else if (!r->time_blocked) 
-                r->time_blocked = NonZeroTime(now);
+			if (mDNSStorage.SleepState != SleepState_Awake) r->time_blocked = 0;
+			else if (!r->time_blocked) r->time_blocked = NonZeroTime(now);
             else if (now - r->time_blocked >= 10 * mDNSPlatformOneSecond * (r->unresponsiveness_reports+1))
             {
                 int num = 0;
                 struct reply_state *x = r->replies;
-                while (x) 
-                { 
-                    num++; 
-                    x=x->next; 
-                }
-                LogMsg("%3d: Could not write data to client PID[%d](%s) after %ld seconds, %d repl%s waiting",
-                       r->sd, r->process_id, r->pid_name, (now - r->time_blocked) / mDNSPlatformOneSecond, num, num == 1 ? "y" : "ies");
+				while (x) { num++; x=x->next; }
+				LogMsg("%3d: Could not write data to client after %ld seconds, %d repl%s waiting",
+					r->sd, (now - r->time_blocked) / mDNSPlatformOneSecond, num, num == 1 ? "y" : "ies");
                 if (++r->unresponsiveness_reports >= 60)
                 {
-                    LogMsg("%3d: Client PID[%d](%s) unresponsive; aborting connection", r->sd, r->process_id, r->pid_name);
+					LogMsg("%3d: Client unresponsive; aborting connection", r->sd);
                     LogClientInfo(&mDNSStorage, r);
                     abort_request(r);
                 }
@@ -6133,6 +4779,7 @@
         {
             // Since we're already doing a list traversal, we unlink the request directly instead of using AbortUnlinkAndFree()
             *req = r->next;
+			//freeL("request_state/udsserver_idle", r);
             os_free(r);
         }
         else
@@ -6146,10 +4793,10 @@
     // Check our structures are reasonable sizes. Including overly-large buffers, or embedding
     // other overly-large structures instead of having a pointer to them, can inadvertently
     // cause structure sizes (and therefore memory usage) to balloon unreasonably.
-    char sizecheck_request_state          [(sizeof(request_state)           <= 2000) ? 1 : -1];
+	char sizecheck_request_state          [(sizeof(request_state)           <= 1784) ? 1 : -1];
     char sizecheck_registered_record_entry[(sizeof(registered_record_entry) <=   60) ? 1 : -1];
     char sizecheck_service_instance       [(sizeof(service_instance)        <= 6552) ? 1 : -1];
-    char sizecheck_browser_t              [(sizeof(browser_t)               <= 1096) ? 1 : -1];
+	char sizecheck_browser_t              [(sizeof(browser_t)               <= 1050) ? 1 : -1];
     char sizecheck_reply_hdr              [(sizeof(reply_hdr)               <=   12) ? 1 : -1];
     char sizecheck_reply_state            [(sizeof(reply_state)             <=   64) ? 1 : -1];
 };
