<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MT7682 API Reference: GDMA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="MediaTek.PNG"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MT7682 API Reference
   &#160;<span id="projectnumber">LinkIt SDK v4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___g_d_m_a.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">GDMA<div class="ingroups"><a class="el" href="group___h_a_l.html">HAL</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This section introduces the General Direct Memeory Access(GDMA) APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, GDMA function groups, enums, structures and functions.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>This section introduces the General Direct Memeory Access(GDMA) APIs including terms and acronyms, supported features, software architecture, details on how to use this driver, GDMA function groups, enums, structures and functions. </p>
<h1><a class="anchor" id="HAL_GDMA_Terms_Chapter"></a>
Terms and acronyms</h1>
<table class="doxtable">
<tr>
<th>Terms </th><th>Details  </th></tr>
<tr>
<td><b>GDMA</b> </td><td>General Direct Memeory Access. GDMA is an operation in which data is copied (transported) from one resource to another in a computer system without the involvement of the CPU. </td></tr>
</table>
<p>For more information, please refer to <a href="https://en.wikipedia.org/wiki/Direct_memory_access">GDMA in Wikipedia </a>.| </p>
<h1><a class="anchor" id="GDMA_Features_Chapter"></a>
Supported features</h1>
<ul>
<li><b>Support</b> <b>polling</b> <b>and</b> <b>interrupt</b> <b>modes</b> GDMA can copy data from source memory to destination memory, instead of from memory to I/O-device or I/O-device to memory.<ul>
<li><b>Polling</b> <b>mode:</b> In the polling mode, the execution status of the GDMA hardware returns valid during the transaction and invalid once the data transaction is finished. The status is retrieved only after the transaction is finished.</li>
<li><b>Interrupt</b> <b>mode:</b> In this mode, the GDMA hardware generates an interrupt once the transaction is complete. <br />
 <br />
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="GDMA_Architecture_Chapter"></a>
Software architecture of the GDMA</h1>
<p>The software architecture of GDMA driver is shown below.</p><ol type="1">
<li>GDMA polling mode architecture :<br />
Call the function <a class="el" href="group___g_d_m_a.html#ga324051352528cccc5e3b0ffdc4aaa8db" title="This function initializes the GDMA based configuration. ">hal_gdma_init()</a> to initialize the GDMA source clock.<br />
Call the function <a class="el" href="group___g_d_m_a.html#ga33afa5d8cbab4602dd044671f68d5046" title="This function enables the GDMA to operate in a polling mode. ">hal_gdma_start_polling()</a> to transfer data.<br />
Call the function <a class="el" href="group___g_d_m_a.html#ga83246b2946abd0215ee528959ce86606" title="This function stops the GDMA operation. ">hal_gdma_stop()</a> to stop the GDMA data transfer.<br />
Call the function <a class="el" href="group___g_d_m_a.html#gaa055b925819322f9962a5b412e6ed290" title="This function gets the current state of the GDMA. ">hal_gdma_get_running_status()</a> to get the status, either busy or idle. The application can also de-initialize the GDMA by calling <a class="el" href="group___g_d_m_a.html#ga0a1cc5084b368aea7ff9ba81523d857e" title="This function resets GDMA registers and state. ">hal_gdma_deinit()</a>.<br />
 Polling mode architecture is similar to the polling mode architecture in HAL. See <a class="el" href="group___h_a_l.html#HAL_Overview_3_Chapter">HAL Driver Model</a> for polling mode architecture.</li>
<li>GDMA interrupt mode architecture :<br />
Call the function <a class="el" href="group___g_d_m_a.html#ga324051352528cccc5e3b0ffdc4aaa8db" title="This function initializes the GDMA based configuration. ">hal_gdma_init()</a> to initialize the GDMA source clock.<br />
Call the function <a class="el" href="group___g_d_m_a.html#gaa7d51364a7141e60b0c448e548b59073" title="This function registers a GDMA callback. ">hal_gdma_register_callback()</a> to register user's callback, and then call the function <a class="el" href="group___g_d_m_a.html#gab76c7dfbbdf30d1e4e940748cde90336" title="This function enables the GDMA to operate in an interrupt mode, the application can register a callba...">hal_gdma_start_interrupt()</a> to transfer data.<br />
Call the function <a class="el" href="group___g_d_m_a.html#ga83246b2946abd0215ee528959ce86606" title="This function stops the GDMA operation. ">hal_gdma_stop()</a> to stop GDMA data transfer.<br />
Call the function <a class="el" href="group___g_d_m_a.html#gaa055b925819322f9962a5b412e6ed290" title="This function gets the current state of the GDMA. ">hal_gdma_get_running_status()</a> to get the status, either busy or idle.<br />
Call the function <a class="el" href="group___g_d_m_a.html#ga0a1cc5084b368aea7ff9ba81523d857e" title="This function resets GDMA registers and state. ">hal_gdma_deinit()</a> to de-initialize GDMA to its original state.<br />
Interrupt mode architecture is similar to the interrupt mode architecture in HAL. See <a class="el" href="group___h_a_l.html#HAL_Overview_3_Chapter">HAL Driver Model</a> for interrupt mode architecture.</li>
</ol>
<h1><a class="anchor" id="GDMA_Driver_Usage_Chapter"></a>
How to use this driver</h1>
<ul>
<li>Use GDMA with polling mode. <br />
<ul>
<li>Step1: Call <a class="el" href="group___g_d_m_a.html#ga324051352528cccc5e3b0ffdc4aaa8db" title="This function initializes the GDMA based configuration. ">hal_gdma_init()</a> to initialize GDMA source clock.</li>
<li>Step2: Call <a class="el" href="group___g_d_m_a.html#ga33afa5d8cbab4602dd044671f68d5046" title="This function enables the GDMA to operate in a polling mode. ">hal_gdma_start_polling()</a> to transfer data.</li>
<li>Step3: Call <a class="el" href="group___g_d_m_a.html#gaa055b925819322f9962a5b412e6ed290" title="This function gets the current state of the GDMA. ">hal_gdma_get_running_status()</a> to get the status, either busy or idle.</li>
<li>Step4: Call <a class="el" href="group___g_d_m_a.html#ga83246b2946abd0215ee528959ce86606" title="This function stops the GDMA operation. ">hal_gdma_stop()</a> to stop GDMA.</li>
<li>Step5: Call <a class="el" href="group___g_d_m_a.html#ga0a1cc5084b368aea7ff9ba81523d857e" title="This function resets GDMA registers and state. ">hal_gdma_deinit()</a> to de-initialize GDMA. <div class="fragment"><div class="line">Note 1. To use DMA:</div><div class="line">       - Memory should be non-cacheable.</div><div class="line">       - Memory address should be 4 bytes aligned.</div><div class="line">Note 2. To <span class="keyword">get</span> non-cacheable memory:</div><div class="line">       - Define a global data array and add a memory attribute.</div><div class="line">                  ATTR_ZIDATA_IN_NONCACHED_RAM_4BYTE_ALIGN, <span class="keywordflow">if</span> the array has no initial value.</div><div class="line">                  ATTR_RWDATA_IN_NONCACHED_RAM_4BYTE_ALIGN, <span class="keywordflow">if</span> the array has an initial value.</div><div class="line">         Example:  ATTR_ZIDATA_IN_NONCACHED_RAM_4BYTE_ALIGN <span class="keyword">static</span> uint8_t  source_address[data_length];</div><div class="line">                  ATTR_ZIDATA_IN_NONCACHED_RAM_4BYTE_ALIGN <span class="keyword">static</span> uint8_t  destination_address[data_length];</div><div class="line">        - Apply memory dynamically with an API <span class="keywordtype">void</span>* PvPortMallocNC(<span class="keywordtype">size_t</span> xWantedSize).</div><div class="line">         Example:  <span class="keywordtype">char</span> *source_address= PvPortMallocNC(data_length);</div><div class="line">                   <span class="keywordtype">char</span> *destination_address= PvPortMallocNC(data_length);</div><div class="line">Note 3. To apply UART/SPI/I2C<span class="stringliteral">&#39;s in DMA mode, please follow Note 2.</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">   static uint32_t dma_length = 64;</span></div><div class="line"><span class="stringliteral">   ATTR_ZIDATA_IN_NONCACHED_RAM_4BYTE_ALIGN static uint8_t  source_address[64];</span></div><div class="line"><span class="stringliteral">   ATTR_ZIDATA_IN_NONCACHED_RAM_4BYTE_ALIGN static uint8_t  destination_address[64];</span></div><div class="line"><span class="stringliteral">   hal_gdma_running_status_t running_status;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">   if(HAL_GDMA_STATUS_OK != hal_gdma_init(HAL_GDMA_CHANNEL0)) { // Initialize the GDMA source clock.</span></div><div class="line"><span class="stringliteral">         // Error handle.</span></div><div class="line"><span class="stringliteral">   }</span></div><div class="line"><span class="stringliteral">   if(HAL_GDMA_STATUS_OK != hal_gdma_start_polling(HAL_GDMA_CHANNEL0, destination_address, source_address, data_length)) {</span></div><div class="line"><span class="stringliteral">         // Error handle.</span></div><div class="line"><span class="stringliteral">   }</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">   hal_gdma_get_running_status(HAL_GDMA_CHANNEL0,&amp;running_status);</span></div><div class="line"><span class="stringliteral">   //...</span></div><div class="line"><span class="stringliteral">   hal_gdma_stop(HAL_GDMA_CHANNEL0); // Stop GDMA.</span></div><div class="line"><span class="stringliteral">   hal_gdma_deinit(HAL_GDMA_CHANNEL0);   // De-initialize the GDMA.</span></div></div><!-- fragment --></li>
</ul>
</li>
<li>Use GDMA with interrupt mode. <br />
<ul>
<li>Step1: Call <a class="el" href="group___g_d_m_a.html#ga324051352528cccc5e3b0ffdc4aaa8db" title="This function initializes the GDMA based configuration. ">hal_gdma_init()</a> to initialize GDMA source clock.</li>
<li>Step2: call <a class="el" href="group___g_d_m_a.html#gaa7d51364a7141e60b0c448e548b59073" title="This function registers a GDMA callback. ">hal_gdma_register_callback()</a> to register a callback function.</li>
<li>Step3: Call <a class="el" href="group___g_d_m_a.html#gab76c7dfbbdf30d1e4e940748cde90336" title="This function enables the GDMA to operate in an interrupt mode, the application can register a callba...">hal_gdma_start_interrupt()</a> to transfer data.</li>
<li>Step4: Call <a class="el" href="group___g_d_m_a.html#gaa055b925819322f9962a5b412e6ed290" title="This function gets the current state of the GDMA. ">hal_gdma_get_running_status()</a> to get the status, either busy or idle.</li>
<li>Step5: Call <a class="el" href="group___g_d_m_a.html#ga83246b2946abd0215ee528959ce86606" title="This function stops the GDMA operation. ">hal_gdma_stop()</a> to stop GDMA.</li>
<li>Step6: Call <a class="el" href="group___g_d_m_a.html#ga0a1cc5084b368aea7ff9ba81523d857e" title="This function resets GDMA registers and state. ">hal_gdma_deinit()</a> to de-initialize GDMA.</li>
<li>Sample code: <div class="fragment"><div class="line">Note 1. To use DMA:</div><div class="line">       - Memory should be non-cacheable.</div><div class="line">       - Memory address should be 4 bytes aligned.</div><div class="line">Note 2. To <span class="keyword">get</span> non-cacheable memory:</div><div class="line">       - Define a global data array and add a memory attribute.</div><div class="line">                  ATTR_ZIDATA_IN_NONCACHED_RAM_4BYTE_ALIGN, <span class="keywordflow">if</span> the array has no initial value.</div><div class="line">                  ATTR_RWDATA_IN_NONCACHED_RAM_4BYTE_ALIGN, <span class="keywordflow">if</span> the array has an initial value.</div><div class="line">         Example:  ATTR_ZIDATA_IN_NONCACHED_RAM_4BYTE_ALIGN <span class="keyword">static</span> uint8_t  source_address[data_length];</div><div class="line">                  ATTR_ZIDATA_IN_NONCACHED_RAM_4BYTE_ALIGN <span class="keyword">static</span> uint8_t  destination_address[data_length];</div><div class="line">        - Apply memory dynamically with an API <span class="keywordtype">void</span>* PvPortMallocNC(<span class="keywordtype">size_t</span> xWantedSize).</div><div class="line">         Example:  <span class="keywordtype">char</span> *source_address= PvPortMallocNC(data_length);</div><div class="line">                   <span class="keywordtype">char</span> *destination_address= PvPortMallocNC(data_length);</div><div class="line">Note 3. To apply UART/SPI/I2C<span class="stringliteral">&#39;s in DMA mode, please follow Note 2.</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">   static uint32_t dma_length = 64;</span></div><div class="line"><span class="stringliteral">   ATTR_ZIDATA_IN_NONCACHED_RAM_4BYTE_ALIGN static uint8_t  source_address[64];</span></div><div class="line"><span class="stringliteral">   ATTR_ZIDATA_IN_NONCACHED_RAM_4BYTE_ALIGN static uint8_t  destination_address[64];</span></div><div class="line"><span class="stringliteral">   uint32_t user_data;</span></div><div class="line"><span class="stringliteral">   user_data = 1;//this value will be passed to the application once the callback function is called</span></div><div class="line"><span class="stringliteral">   hal_gdma_running_status_t running_status;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">   if(HAL_GDMA_STATUS_OK != hal_gdma_init(HAL_GDMA_CHANNEL0)) { // Initialize the GDMA source clock.</span></div><div class="line"><span class="stringliteral">         // Error handle.</span></div><div class="line"><span class="stringliteral">   }</span></div><div class="line"><span class="stringliteral">   if(HAL_GDMA_STATUS_OK != hal_gdma_register_callback(HAL_GDMA_CHANNEL0, callback,(void *) &amp;user_data) {  // Register user&#39;</span>s callback.</div><div class="line">         <span class="comment">// Error handle.</span></div><div class="line">   }</div><div class="line">   <span class="keywordflow">if</span>(<a class="code" href="group__hal__gdma__enum.html#ggac32be0cf0ab425d4dbd06b5aa0fa51caaa78e636ff5c8bad405998e1c9090a726">HAL_GDMA_STATUS_OK</a> != <a class="code" href="group___g_d_m_a.html#gab76c7dfbbdf30d1e4e940748cde90336">hal_gdma_start_interrupt</a>(HAL_GDMA_CHANNEL0,  destination_address, source_address, data_length)) { <span class="comment">//Enable GDMA to start transferring data.</span></div><div class="line">         <span class="comment">// Error handle.</span></div><div class="line">   }</div><div class="line">   <span class="comment">//...</span></div><div class="line">   <a class="code" href="group___g_d_m_a.html#gaa055b925819322f9962a5b412e6ed290">hal_gdma_get_running_status</a>(HAL_GDMA_CHANNEL0, &amp;running_status);</div><div class="line">   <span class="comment">//...</span></div><div class="line">   <a class="code" href="group___g_d_m_a.html#ga83246b2946abd0215ee528959ce86606">hal_gdma_stop</a>(HAL_GDMA_CHANNEL0); <span class="comment">// Stop the GDMA.</span></div><div class="line">   <a class="code" href="group___g_d_m_a.html#ga0a1cc5084b368aea7ff9ba81523d857e">hal_gdma_deinit</a>(HAL_GDMA_CHANNEL0);   <span class="comment">//De-initialize the GDMA.</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="comment">// Callback function. This function should be registered with hal_gdma_register_callback().</span></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> gdma_callback(<a class="code" href="group__hal__gdma__enum.html#ga6691b13723b5350394209a735688443d">hal_gdma_event_t</a> event, <span class="keywordtype">void</span>  *user_data)</div><div class="line">  {  <span class="comment">//gdma_callback will be triggered when gdma transfers finished.</span></div><div class="line">     <span class="comment">//add your code here, such as:</span></div><div class="line"></div><div class="line">        <a class="code" href="group___g_d_m_a.html#ga83246b2946abd0215ee528959ce86606">hal_gdma_stop</a>(HAL_GDMA_CHANNEL0);</div><div class="line">        <a class="code" href="group___g_d_m_a.html#ga0a1cc5084b368aea7ff9ba81523d857e">hal_gdma_deinit</a>(HAL_GDMA_CHANNEL0);</div><div class="line">        printf(<span class="stringliteral">&quot;\r\n ---gdma_example finished!!!---\r\n&quot;</span>);</div><div class="line">  }</div></div><!-- fragment --> </li>
</ul>
</li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga324051352528cccc5e3b0ffdc4aaa8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_d_m_a.html#ga324051352528cccc5e3b0ffdc4aaa8db">hal_gdma_init</a> (<a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a> channel)</td></tr>
<tr class="memdesc:ga324051352528cccc5e3b0ffdc4aaa8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the GDMA based configuration.  <a href="#ga324051352528cccc5e3b0ffdc4aaa8db">More...</a><br /></td></tr>
<tr class="separator:ga324051352528cccc5e3b0ffdc4aaa8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a1cc5084b368aea7ff9ba81523d857e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_d_m_a.html#ga0a1cc5084b368aea7ff9ba81523d857e">hal_gdma_deinit</a> (<a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a> channel)</td></tr>
<tr class="memdesc:ga0a1cc5084b368aea7ff9ba81523d857e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets GDMA registers and state.  <a href="#ga0a1cc5084b368aea7ff9ba81523d857e">More...</a><br /></td></tr>
<tr class="separator:ga0a1cc5084b368aea7ff9ba81523d857e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33afa5d8cbab4602dd044671f68d5046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_d_m_a.html#ga33afa5d8cbab4602dd044671f68d5046">hal_gdma_start_polling</a> (<a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a> channel, uint32_t destination_address, uint32_t source_address, uint32_t data_length)</td></tr>
<tr class="memdesc:ga33afa5d8cbab4602dd044671f68d5046"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the GDMA to operate in a polling mode.  <a href="#ga33afa5d8cbab4602dd044671f68d5046">More...</a><br /></td></tr>
<tr class="separator:ga33afa5d8cbab4602dd044671f68d5046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76c7dfbbdf30d1e4e940748cde90336"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_d_m_a.html#gab76c7dfbbdf30d1e4e940748cde90336">hal_gdma_start_interrupt</a> (<a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a> channel, uint32_t destination_address, uint32_t source_address, uint32_t data_length)</td></tr>
<tr class="memdesc:gab76c7dfbbdf30d1e4e940748cde90336"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables the GDMA to operate in an interrupt mode, the application can register a callback when a GDMA interrupt occurs.  <a href="#gab76c7dfbbdf30d1e4e940748cde90336">More...</a><br /></td></tr>
<tr class="separator:gab76c7dfbbdf30d1e4e940748cde90336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d51364a7141e60b0c448e548b59073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_d_m_a.html#gaa7d51364a7141e60b0c448e548b59073">hal_gdma_register_callback</a> (<a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a> channel, <a class="el" href="group__hal__gdma__typedef.html#gad032df535906b3634287974ad09a0605">hal_gdma_callback_t</a> callback, void *user_data)</td></tr>
<tr class="memdesc:gaa7d51364a7141e60b0c448e548b59073"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function registers a GDMA callback.  <a href="#gaa7d51364a7141e60b0c448e548b59073">More...</a><br /></td></tr>
<tr class="separator:gaa7d51364a7141e60b0c448e548b59073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa055b925819322f9962a5b412e6ed290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_d_m_a.html#gaa055b925819322f9962a5b412e6ed290">hal_gdma_get_running_status</a> (<a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a> channel, <a class="el" href="group__hal__gdma__enum.html#ga8edd57cd0ec52a15c4513440adb9c554">hal_gdma_running_status_t</a> *running_status)</td></tr>
<tr class="memdesc:gaa055b925819322f9962a5b412e6ed290"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current state of the GDMA.  <a href="#gaa055b925819322f9962a5b412e6ed290">More...</a><br /></td></tr>
<tr class="separator:gaa055b925819322f9962a5b412e6ed290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83246b2946abd0215ee528959ce86606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___g_d_m_a.html#ga83246b2946abd0215ee528959ce86606">hal_gdma_stop</a> (<a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a> channel)</td></tr>
<tr class="memdesc:ga83246b2946abd0215ee528959ce86606"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops the GDMA operation.  <a href="#ga83246b2946abd0215ee528959ce86606">More...</a><br /></td></tr>
<tr class="separator:ga83246b2946abd0215ee528959ce86606"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__hal__gdma__enum"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal__gdma__enum.html">Enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__hal__gdma__typedef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hal__gdma__typedef.html">Typedef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0a1cc5084b368aea7ff9ba81523d857e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a> hal_gdma_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets GDMA registers and state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>GDMA master name definition in enum <a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb" title="gdma channel ">hal_gdma_channel_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>To indicate whether this function call is successful or not. <a class="el" href="group__hal__gdma__enum.html#ggac32be0cf0ab425d4dbd06b5aa0fa51caaa78e636ff5c8bad405998e1c9090a726" title="GDMA completed successfully. ">HAL_GDMA_STATUS_OK</a>, the operation completed successfully. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Sample code, please refer to <a class="el" href="group___g_d_m_a.html#GDMA_Driver_Usage_Chapter">How to use this driver</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___g_d_m_a.html#ga324051352528cccc5e3b0ffdc4aaa8db" title="This function initializes the GDMA based configuration. ">hal_gdma_init()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa055b925819322f9962a5b412e6ed290"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a> hal_gdma_get_running_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hal__gdma__enum.html#ga8edd57cd0ec52a15c4513440adb9c554">hal_gdma_running_status_t</a> *&#160;</td>
          <td class="paramname"><em>running_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current state of the GDMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>GDMA master name definition in enum <a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb" title="gdma channel ">hal_gdma_channel_t</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">running_status</td><td>is the current running status. <a class="el" href="group__hal__gdma__enum.html#gga8edd57cd0ec52a15c4513440adb9c554a946eb5e19c675489c98a5a55f0ce0c9b" title="GDMA busy. ">HAL_GDMA_BUSY</a>, the GDMA is busy. <a class="el" href="group__hal__gdma__enum.html#gga8edd57cd0ec52a15c4513440adb9c554adb7a22e158da1c2594b4d7047fab948e" title="GDMA idle. ">HAL_GDMA_IDLE</a>, the GDMA is idle and ready to transfer data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>To indicate whether this function call is successful or not. <a class="el" href="group__hal__gdma__enum.html#ggac32be0cf0ab425d4dbd06b5aa0fa51caaa78e636ff5c8bad405998e1c9090a726" title="GDMA completed successfully. ">HAL_GDMA_STATUS_OK</a>, the operation completed successfully. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Sample code, please refer to <a class="el" href="group___g_d_m_a.html#GDMA_Driver_Usage_Chapter">How to use this driver</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___g_d_m_a.html#gab76c7dfbbdf30d1e4e940748cde90336" title="This function enables the GDMA to operate in an interrupt mode, the application can register a callba...">hal_gdma_start_interrupt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga324051352528cccc5e3b0ffdc4aaa8db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a> hal_gdma_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the GDMA based configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>GDMA definition in enum <a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb" title="gdma channel ">hal_gdma_channel_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>To indicate whether this function call is successful or not. <a class="el" href="group__hal__gdma__enum.html#ggac32be0cf0ab425d4dbd06b5aa0fa51caaa78e636ff5c8bad405998e1c9090a726" title="GDMA completed successfully. ">HAL_GDMA_STATUS_OK</a>, the operation completed successfully. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Sample code, please refer to <a class="el" href="group___g_d_m_a.html#GDMA_Driver_Usage_Chapter">How to use this driver</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___g_d_m_a.html#ga0a1cc5084b368aea7ff9ba81523d857e" title="This function resets GDMA registers and state. ">hal_gdma_deinit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7d51364a7141e60b0c448e548b59073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a> hal_gdma_register_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hal__gdma__typedef.html#gad032df535906b3634287974ad09a0605">hal_gdma_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function registers a GDMA callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>GDMA master name definition in enum <a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb" title="gdma channel ">hal_gdma_channel_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>is the callback function given by the application, that is called at the GDMA interrupt service routine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>is a user input provided by the application and is passed to the application once the callback function is called. See the last parameter of <a class="el" href="group__hal__gdma__typedef.html#gad032df535906b3634287974ad09a0605" title="This defines the callback function prototype. ">hal_gdma_callback_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Sample code, please refer to <a class="el" href="group___g_d_m_a.html#GDMA_Driver_Usage_Chapter">How to use this driver</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___g_d_m_a.html#gab76c7dfbbdf30d1e4e940748cde90336" title="This function enables the GDMA to operate in an interrupt mode, the application can register a callba...">hal_gdma_start_interrupt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab76c7dfbbdf30d1e4e940748cde90336"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a> hal_gdma_start_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>destination_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>source_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the GDMA to operate in an interrupt mode, the application can register a callback when a GDMA interrupt occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>GDMA master name definition in enum <a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb" title="gdma channel ">hal_gdma_channel_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destination_address</td><td>is the address to copy the source data into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_address</td><td>is the address where application's source data is stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_length</td><td>is the data length used in the transaction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>To indicate whether this function call is successful or not. <a class="el" href="group__hal__gdma__enum.html#ggac32be0cf0ab425d4dbd06b5aa0fa51caaa78e636ff5c8bad405998e1c9090a726" title="GDMA completed successfully. ">HAL_GDMA_STATUS_OK</a>, the operation completed successfully. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Sample code, please refer to <a class="el" href="group___g_d_m_a.html#GDMA_Driver_Usage_Chapter">How to use this driver</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___g_d_m_a.html#ga33afa5d8cbab4602dd044671f68d5046" title="This function enables the GDMA to operate in a polling mode. ">hal_gdma_start_polling()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga33afa5d8cbab4602dd044671f68d5046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a> hal_gdma_start_polling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>destination_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>source_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables the GDMA to operate in a polling mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>GDMA master name definition in enum <a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb" title="gdma channel ">hal_gdma_channel_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destination_address</td><td>is the address to copy the source data into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_address</td><td>is the address where application's source data is stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_length</td><td>is the data length used in the transaction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>To indicate whether this function call is successful or not. <a class="el" href="group__hal__gdma__enum.html#ggac32be0cf0ab425d4dbd06b5aa0fa51caaa78e636ff5c8bad405998e1c9090a726" title="GDMA completed successfully. ">HAL_GDMA_STATUS_OK</a>, the operation completed successfully. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Sample code, please refer to <a class="el" href="group___g_d_m_a.html#GDMA_Driver_Usage_Chapter">How to use this driver</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___g_d_m_a.html#gab76c7dfbbdf30d1e4e940748cde90336" title="This function enables the GDMA to operate in an interrupt mode, the application can register a callba...">hal_gdma_start_interrupt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga83246b2946abd0215ee528959ce86606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hal__gdma__enum.html#gac32be0cf0ab425d4dbd06b5aa0fa51ca">hal_gdma_status_t</a> hal_gdma_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb">hal_gdma_channel_t</a>&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops the GDMA operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>GDMA master name definition in enum <a class="el" href="group__hal__gdma__enum.html#ga53d251c169aceba4196da7809100dcbb" title="gdma channel ">hal_gdma_channel_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>To indicate whether this function call is successful or not. <a class="el" href="group__hal__gdma__enum.html#ggac32be0cf0ab425d4dbd06b5aa0fa51caaa78e636ff5c8bad405998e1c9090a726" title="GDMA completed successfully. ">HAL_GDMA_STATUS_OK</a>, the operation completed successfully. </dd></dl>
<dl class="section user"><dt>Example</dt><dd>Sample code, please refer to <a class="el" href="group___g_d_m_a.html#GDMA_Driver_Usage_Chapter">How to use this driver</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___g_d_m_a.html#ga33afa5d8cbab4602dd044671f68d5046" title="This function enables the GDMA to operate in a polling mode. ">hal_gdma_start_polling()</a>, <a class="el" href="group___g_d_m_a.html#gab76c7dfbbdf30d1e4e940748cde90336" title="This function enables the GDMA to operate in an interrupt mode, the application can register a callba...">hal_gdma_start_interrupt()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 21 2017 10:19:01 for MT7682 API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
