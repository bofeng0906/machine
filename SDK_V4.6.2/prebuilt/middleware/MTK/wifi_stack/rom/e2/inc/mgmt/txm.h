/*
** $Id: //Department/DaVinci/TRUNK/MT6620_WiFi_Firmware/mcu/wifi/include/mgmt/txm.h#45 $
*/

/*! \file   txm.c
    \brief  Transmit Manager (TXM) handles tasks related to TX, including HIF TX handling and MAC TX handling

    TXM module forwards packets generated by FW or Host to MAC HW. TXM communicates with HAL
    for sending packets via MAC TX DMA or receiving packets via HIF TX DMA.
*/

/*******************************************************************************
* Copyright (c) 2007 MediaTek Inc.
*
* All rights reserved. Copying, compilation, modification, distribution
* or any other use whatsoever of this material is strictly prohibited
* except in accordance with a Software License Agreement with
* MediaTek Inc.
********************************************************************************
*/

/*******************************************************************************
* LEGAL DISCLAIMER
*
* BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND
* AGREES THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK
* SOFTWARE") RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE
* PROVIDED TO BUYER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY
* DISCLAIMS ANY AND ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT
* LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
* PARTICULAR PURPOSE OR NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE
* ANY WARRANTY WHATSOEVER WITH RESPECT TO THE SOFTWARE OF ANY THIRD PARTY
* WHICH MAY BE USED BY, INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK
* SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY
* WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE
* FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S SPECIFICATION OR TO
* CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
* BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
* LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL
* BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT
* ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY
* BUYER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
* THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
* WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT
* OF LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING
* THEREOF AND RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN
* FRANCISCO, CA, UNDER THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE
* (ICC).
********************************************************************************
*/

/*
** $Log: txm.h $
**
** 12 01 2015 raju.singh
** [BORA00005537] [MT7637E2][IoT][FW]Throughput too low in frame forwarding
** 1) Purpose: To make N9 backward compitable to older CM4 after Rx-Zero copy forwarding support enabled.
** 	Issues fixed:
** 	1- Beaconing not happening
** 	2- Compatability issue in STA mode.
** 	3- Low throughput issue in STA mode.
** 
** 	2) Changed function name:
** 	   - Iot_init_profile
** 	   - bssEnqBcnPktFromCmd
** 	   - txmAllocPkt
** 	   - txmGetPktBuffer
** 	   - txmGetPktBufferInPse
** 	   - txmComposeDesc	
** 	3) Code change description brief: Rx-zero copy forwarding will be enabled based on NVRAM configuration.
** 	
** 	4) Unit Test Result: PASS
** 	
** 	
** 	<CRID START> <CRID END>
**
** 11 24 2015 raju.singh
** [BORA00005537] [MT7637E2][IoT][FW]Throughput too low in frame forwarding
** 	
** 	1) Purpose: Implement Rx-Zero copy in intra-bass forwarding
** 	
** 	2) Changed function name:
** 	   - patch__PseKickOutTx
** 	   - patch__RTMPWriteTxWI
** 	   - patch__RTMPWriteTxWI_Data
** 	   - patch__RTMPWriteTxWI_Cache
** 	   - patch__MlmeHardTransmitMgmtRing
** 	   - patch__MiniportMMRequest		
** 	   - patch__APRxFowardHandle
** 	   - patch__Announce_or_Forward_802_3_Packet
** 	   - setOpMode
** 	3) Code change description brief: RxD configured to 12DW so that it can accomodated 8DW TxD and 4DW padding. By this configuration Rx-Zero copy is achieved in intra-bss forwarding.
** 	
** 	4) Unit Test Result: PASS
** 	
** 	
** 	<CRID START> <CRID END>
**
** 07 24 2015 tiger.hung
** [BORA00004558] [MT7637][E2] Checkin
** Sync E1 Ram code(CL28812) to E2
**
** 06 25 2015 th3.huang
** [BORA00004658] MT7637 Check in
** 1. Merge from MT7615_E1 27674:set StaRec default rate as RA rate table..
**
** 06 14 2015 ted.huang
** [BORA00003379] [MT7637]
** Support default rate.
**
** 05 29 2015 litien.chang
** [BORA00003962] [MT7637]
** 	[Wifi] default TXM_RTS_SIGNAL_TA_ENABLE 0
**
** 05 28 2015 litien.chang
** [BORA00003962] [MT7637]
** [WIFI] set AGG.ALLCR.AGGLimit to 45
**
** 03 17 2015 litien.chang
** [BORA00003962] [MT7637]
** [Wifi] Set BAR rate = OFDM 6M for 5G band
**
** 03 13 2015 litien.chang
** [BORA00003962] [MT7637]
** [Wifi] Add MAC init offload
**
** 02 14 2015 ted.huang
** [BORA00003379] [MT7637]
** Merge 7615 FW RAM change .
**
** 09 15 2014 ted.huang
** [BORA00002807] [MT7636]
** merge MT7636 back main trunk.
**
** 07 15 2014 tiger.hung
** [BORA00003241] [MT7636] sync MT7636 E1 MP source code
**
** 06 20 2014 danielk.lu
** [BORA00003002] [MT7636][WiFi]
** Support Keep Alive Offload
**
** 05 01 2014 posh.sun
** [BORA00002806] [Wi-Fi][General] Add MT7636 Project Settings
** Refine Code
**
** 03 26 2014 ted.huang
** [BORA00002807] [MT7636]
** PS-POLL offload and TX redirect.
**
** 03 23 2014 posh.sun
** [BORA00002806] [Wi-Fi][General] Add MT7636 Project Settings
** Align 20140319 Calibration Seq and Disable DMA Scheduler for SDIO
**
** 03 10 2014 ted.huang
** [BORA00002807] [MT7636]
** Merge WIFI RAM from main trunk.
**
** 02 12 2014 posh.sun
** [BORA00002806] [Wi-Fi][General] Add MT7636 Project Settings
** Add DMA Scheduler Feature Option
**
** 02 10 2014 ted.huang
** [BORA00002807] [MT7636]
** merge new inband cmd from 7603.
**
** 01 08 2014 ted.huang
** [BORA00002807] [MT7636]
** Merge 6630E2 RAM code.
**
*/

#ifndef _TXM_H_
#define _TXM_H_

#if (BUILD_FOR_PATCH == 5)
#include "patch_config.h"
#endif
/*******************************************************************************
*                         C O M P I L E R   F L A G S
********************************************************************************
*/

/*******************************************************************************
*                    E X T E R N A L   R E F E R E N C E S
********************************************************************************
*/
#define DISABLE_PREVIOUS_CODE                               0

/*******************************************************************************
*                              C O N S T A N T S
********************************************************************************
*/
//TXM Debug Levels
/* TXM Debug settings */
#define TXM_DBG_LEVEL_BUFFER                                0
#define TXM_DBG_LEVEL_PACKET                                0
#define TXM_DBG_LEVEL_FUNCTION                              0
#define TXM_DBG_LEVEL_QUEUE                                 0
#define TXM_DBG_LEVEL_11N                                   0
#define TXM_DBG_LEVEL_FW_DELAY                              0
#define TXM_DBG_LEVEL_WARNING                               0
#define TXM_DBG_LEVEL_Q_OPERATION                           0

//TXM Features
/* TXM feature enabling flags and settings */
#define TXM_FORCE_64KB_AMPDU_FACTOR                         0
#define TXM_FORCE_16US_MMSS                                 0
#define TXM_INIT_FRAGMENTATION_ENABLED                      1       /* unused */
#define TXM_FRAGMENTATION_THRESHOLD                         0       /* 0: without fragmentation */
#define TXM_MAC_TX_DESC_RESERVED_FOR_OTHER                  4

//TXM Operation Parameters
/* Thresholds and parameters */
#define MAC_TX_BATCH_FORWARDING_THRESHOLD                   1       /* This parameter will affect AMPDU aggregation number */
#define TXM_BAR_RETRY_LIMIT                                 1
#define TXM_AGG_LIMIT                                       45
#define TXM_DEFAULT_REMAINING_LIFE_TIME                     TX_DESC_LIFE_TIME_NO_LIMIT  /* unit: ms */
#define TXM_DEFAULT_MMPDU_RETRY_LIMIT                       30
#define TXM_DEFAULT_DATA_FRAME_RETRY_LIMIT                  0x0f
#define TXM_DEFAULT_PACKET_ID                               2
#define TXM_DEFAULT_PROBE_RSP_RETRY_LIMIT                   2
#define TXM_DEFAULT_RTS_RETRY_LIMIT                         7
#define TXM_DEFAULT_FLUSH_QUEUE_GUARD_TIME                  0       /* Unit: 64 us */
#define TXM_FLUSH_QUEUE_TIMEOUT_LEN                         20000   /* in us */
#define TXM_PAUSE_QUEUE_TIMEOUT_LEN                         20000   /* in us */
#define TXM_TX_DONE_INT_AGG_TIMEOUT                         10      /* in TU */
#define TXM_TX_DONE_INT_AGG_THRESHOLD                       ((8 * NIC_PAGE_NUM_FOR_TX_PKT)) /* in page count */

//TXM Unit Test
#define TXM_TEST_EVENT_ENABLED                              0
#define TXM_TEST_EVENT_INTERVAL                             30000   /* in ms */
#define TXM_TEST_MNG_TX_RATE                                0
#define TXM_TEST_DATA_TX_RATE                               0
#define TXM_TEST_RSP_RATE                                   0
#define TXM_TEST_BA_RSP_RATE                                0
#define TXM_TEST_ACK_RSP_RATE                               0
#define TXM_TEST_CTS_RSP_RATE                               0
#define TXM_TEST_FORCE_RTS_PROTECTION                       0       /* Set the RTS bit in MAC TX DMA Desc */
#define TXM_TEST_QUE_FLUSH_TO_DISCARD                       0
#define TXM_TEST_QUE_FLUSH_TO_MODIFY                        0
#define TXM_TEST_FW_GEN_QOS_NULL_FRAME                      0
#define TXM_TEST_FW_GEN_NULL_FRAME                          0
#define TXM_TEST_DATA_TX_RATE_HT                            0       /* For setting the TX rates in the WLAN table */
#define TXM_TEST_DATA_TX_RATE_HT_RATE                       RATE_MM_MCS_0   /* In effect when TXM_TEST_DATA_TX_RATE_HT == 1 */
#define TXM_TEST_STOP_START_QUEUE                           0
#define TXM_TEST_DUMP_PSE_STATUS                            1
#define TXM_TEST_STA_REC_IDX                                0
#define TXM_TEST_BSS_INFO_IDX                               0
#define TXM_TEST_WTBL_IDX                                   0
#define TXM_TEST_HW_OWN_MAC_IDX                             1

//TXM Workaround
#define TXM_WORKAROUND_AVOID_QUE_LEN_HAL                    1

//TXM Definitions
/* TXM control flag offsets (relative to bit0 of g_prTxm->u4FlagBitmap) */

/* MAC TX Queue Operation Parameters */
#define TXM_FLUSH_QUEUE_MODE_BLOCKING                       TRUE
#define TXM_FLUSH_QUEUE_MODE_NONBLOCKING                    FALSE

#define EVENT_TX_DONE_PACKET_LEN                            12
#define EVENT_BSS_ABSENCE_PRESENCE_LEN                      12
#define EVENT_STA_CHANGE_PS_MODE_LEN                        12
#define EVENT_STA_UPDATE_FREE_QUOTA_LEN                     12

/* Per STA flow control */
#define TXM_PER_STA_FLOW_CONTROL_IN_PS                      1
#define TXM_MAX_BUFFER_PER_STA_DEF                          10

/*------------------------------------------------------------------------*/
/* Tx descriptor related information                                      */
/*------------------------------------------------------------------------*/
/*
 * Frame Buffer
 * |<--Tx Descriptor-->|<--Tx descriptor padding-->|<--802.3/802.11 Header-->|<--Header padding-->|<--Payload-->|
 */

/* Tx descriptor length by format (TXD.FT) */
#if (CFG_SUPPORT_DMA_SCHEDULER == 1)
#define NIC_TX_DESC_LONG_FORMAT_LENGTH_DW                   8       //in unit of double word
#define NIC_TX_DESC_SHORT_FORMAT_LENGTH_DW                  3       //in unit of double word
#else
#define NIC_TX_DESC_LONG_FORMAT_LENGTH_DW                   7       //in unit of double word
#define NIC_TX_DESC_SHORT_FORMAT_LENGTH_DW                  2       //in unit of double word
#endif

#define NIC_TX_DESC_LONG_FORMAT_LENGTH                      DWORD_TO_BYTE(NIC_TX_DESC_LONG_FORMAT_LENGTH_DW)
#define NIC_TX_DESC_SHORT_FORMAT_LENGTH                     DWORD_TO_BYTE(NIC_TX_DESC_SHORT_FORMAT_LENGTH_DW)

/* Tx descriptor padding length (DMA.MICR.TXDSCR_PAD) */
#define NIC_TX_DESC_PADDING_LENGTH_DW                       0       //in unit of double word
#define NIC_TX_DESC_PADDING_LENGTH                          DWORD_TO_BYTE(NIC_TX_DESC_PADDING_LENGTH_DW)

/* Tx header padding (TXD.HeaderPadding)  */
#define NIC_TX_DESC_HEADER_PADDING_LENGTH                   0       //in unit of bytes

#define NIC_TX_DESC_AND_PADDING_LENGTH                      (NIC_TX_DESC_LONG_FORMAT_LENGTH + NIC_TX_DESC_PADDING_LENGTH)

#define NIC_TX_DEFAULT_WLAN_INDEX                           127     //value is TBD. For Tx packets to peer who has no WLAN table index.

#define NIC_TX_DESC_PID_RESERVED                            0
#define NIC_TX_DESC_FW_PID_MIN                              128
#define NIC_TX_DESC_FW_PID_MAX                              255

#define MAC_TX_RESERVED_FIELD                               NIC_TX_DESC_AND_PADDING_LENGTH


/* struct _TX_PKT_INFO_T.ucTxQue: 0xFF indicate TX queue index is decided by API */
#define TXM_PKT_INFO_AUTO_Q_SELECT                          0xFF


/*------------------------------------------------------------------------*/
/* Tx status related information                                          */
/*------------------------------------------------------------------------*/

/* Tx status header & content length */
#define NIC_TX_STATUS_HEADER_LENGTH_DW                      1       //in unit of double word
#define NIC_TX_STATUS_HEADER_LENGTH                         DWORD_TO_BYTE(NIC_TX_STATUS_HEADER_LENGTH_DW)
#define NIC_TX_STATUS_LENGTH_DW                             5       //in unit of double word
#define NIC_TX_STATUS_LENGTH                                DWORD_TO_BYTE(NIC_TX_STATUS_LENGTH_DW)

#define TXM_DEFAULT_TXS_BMP                                 (TX_STATUS_MPDU_ERROR | \
                                                             TX_STATUS_RTS_ERROR | \
                                                             TX_STATUS_LIFETIME_ERROR | \
                                                             TX_STATUS_BIP_ERROR | \
                                                             TX_STATUS_PS_FIELD | \
                                                             TX_STATUS_BA_UNAVAILABLE)

/*------------------------------------------------------------------------*/
/* Tx DBG related information                                             */
/*------------------------------------------------------------------------*/
#define TXM_DBG_COUNTER                                     0

/*------------------------------------------------------------------------*/
/* Tx queue related information                                           */
/*------------------------------------------------------------------------*/

#define TXM_SWITCH_PORT_IDX                                 ENUM_SWITCH_PORT_3
#define TXM_FILTER_DEST_QUEUE_IDX                           ENUM_SWITCH_SW_Q_0

#if (CFG_BCN_OFFLOAD_SUPPORT == 1)
#define TXM_TX_DONE_BCN_DEST_PORT_IDX                       ENUM_LMAC_PORT_2
#define TXM_TX_DONE_BCN_DEST_QUEUE_IDX                      TX_Q_BCN
#else
#define TXM_TX_DONE_BCN_DEST_PORT_IDX                       ENUM_SWITCH_PORT_3
#define TXM_TX_DONE_BCN_DEST_QUEUE_IDX                      ENUM_SWITCH_FREE_Q_8
#endif

#define TXM_BMC_QUEUE_MAX_PKT_COUNT                         TX_Q_BMC_MAX_PKT_COUNT

/*------------------------------------------------------------------------*/
/* Tx time related information                                            */
/*------------------------------------------------------------------------*/

#define TXM_AP_BUFFERED_PKT_AGING_TIME                      10000   //in unit of ms
#define TXM_AP_MIN_BUFFERED_TIME_PER_DTIM                   20      //in unit of DTIM count

/*------------------------------------------------------------------------*/
/* Tx protection related information                                            */
/*------------------------------------------------------------------------*/
#if (MTK_PRODUCTION_RELEASE == 0)
//for RTS/CTS bandwidth signaling failed issue in FPGA mode
#define TXM_RTS_SIGNAL_TA_ENABLE                            0
#define TXM_PRE_RTS_SECCHANNEL_CCA_IDLE                     PRE_RTS_SEC_IDLE_SIFS
#define TXM_RTS_THRESHOLD_ENABLE                            0
#define TXM_RTS_THRESHOLD_IN_PKT_NUM                        0x3F
#define TXM_RTS_THRESHOLD_IN_PKT_LEN                        0xFFFFF
#else
#define TXM_RTS_SIGNAL_TA_ENABLE                            0
#define TXM_PRE_RTS_SECCHANNEL_CCA_IDLE                     PRE_RTS_SEC_IDLE_SIFS_1SLOT
#define TXM_RTS_THRESHOLD_ENABLE                            1
#define TXM_RTS_THRESHOLD_IN_PKT_NUM                        0x2
#define TXM_RTS_THRESHOLD_IN_PKT_LEN                        0x92B
#endif

/*------------------------------------------------------------------------*/
/* Txm init                                                               */
/*------------------------------------------------------------------------*/
#define TXM_INIT_NOBA_RULE                                  NOBA_RETX_AMPDU
#define TXM_INIT_NOBA_AR_RULE                               NOBA_AR_ADD_ONE
#define TXM_INIT_RX2H_QIDX                                  RX2H_QIDX_1
#define TXM_INIT_TXS2H_MAX_AGG_CNT                          31
#define TXM_INIT_TXS2M_MAX_AGG_CNT                          (NIC_TX_STS_MAX_AGG_NUM - 1)
#define TXM_INIT_TX_STREAM_NUM                              1
#define TXM_INIT_SEC_CH_IDLE_SEL                            SEC_CH_IDLE_SEL_PIFS
#define TXM_INIT_RX_REQ_DELAY                               0x4
#if 0
#define TXM_INIT_AIFS_RELOAD_MODE                           CCA_CS_PLD_BUSY_RELOAD
#endif
#define TXM_TX_START_ACQ_BITMAP                             (BIT(TX_Q_AC0) | \
                                                             BIT(TX_Q_AC1) | \
                                                             BIT(TX_Q_AC2) | \
                                                             BIT(TX_Q_AC3) | \
                                                             BIT(TX_Q_AC4) | \
                                                             BIT(TX_Q_AC5) | \
                                                             BIT(TX_Q_AC6) | \
                                                             BIT(TX_Q_AC10) | \
                                                             BIT(TX_Q_AC11) | \
                                                             BIT(TX_Q_AC12) | \
                                                             BIT(TX_Q_AC13) | \
                                                             BIT(TX_Q_AC14))
                                                             
#define EFUSE_TX_STREAM_NUM_OFFSET                           4
#define EFUSE_TX_STREAM_NUM_MASK                             BITS(0,3)
#define EFUSE_TXRX_CONFIG_POS                                0x34

#if (MTK_PRODUCTION_RELEASE == 0)
/*
 * sync. MT7628.c
 * WHQA_00016749, there are a lots of Tx retry in FPGA.
 * per Jacky's comment, enlarge the timeout value of waiting ack.
 * real chip shall not have the symptom.
*/
#define TXM_CCK_CCA_TIMEOUT                                  0xD7                                  
#define TXM_CCK_MDRDY_TIMEOUT                                0xD7
#define TXM_OFDM_CCA_TIMEOUT                                 0xD7
#define TXM_OFDM_MDRDY_TIMEOUT                               0xD7
#else
/* IOT issue with Realtek at CCK mode */
#define TXM_CCK_CCA_TIMEOUT                                  0x30                                  
#define TXM_CCK_MDRDY_TIMEOUT                                0xE7
#define TXM_OFDM_CCA_TIMEOUT                                 0x18
#define TXM_OFDM_MDRDY_TIMEOUT                               0x3C
#endif
/*******************************************************************************
*                             D A T A   T Y P E S
********************************************************************************
*/
typedef enum _ENUM_TX_PKT_TYPE_T
{
    TX_PKT_TYPE_DATA = 0,
    TX_PKT_TYPE_MGMT,
    //TX_PKT_TYPE_1X,
    TX_PKT_TYPE_NUM
} ENUM_TX_PKT_TYPE_T, *P_ENUM_TX_PKT_TYPE_T;

typedef enum _ENUM_MAC_TX_QUEUE_STATUS_T
{
    MAC_TX_QUEUE_STATUS_STARTED = 0,
    //MAC_TX_QUEUE_STATUS_PAUSED,
    MAC_TX_QUEUE_STATUS_STOPPED,
    MAC_TX_QUEUE_STATUS_NUM
} ENUM_MAC_TX_QUEUE_STATUS_T;

typedef enum _ENUM_MAC_QUEUE_FILTER_MODE_T
{
    MAC_QUEUE_FILTER_BY_WTBL_IDX = 0,
    MAC_QUEUE_FILTER_BY_OWN_MAC_IDX,
} ENUM_MAC_QUEUE_FILTER_MODE_T;

#if (CFG_CMD_GET_STATISTIC == 1)
typedef enum _ENUM_TX_STATISTIC_COUNTER_T
{
//  TXM_OS_MSDU_COUNT = 0,                   /* MSDU(Ethernet Frame) before fragmentation */
//  TXM_OS_MSDU_DROP_COUNT,                  /* MSDU(Ethernet Frame) drop count if not connected */
//  TXM_INTERNAL_MSDU_MMPDU_COUNT,           /* MSDU/MMPDU(Frame composed from Internal Protocol Stack) before fragmentation */

    TXM_MPDU_OK_COUNT,                       /* OK = UCAST_OK + BMCAST_OK */
    TXM_MPDU_RTS_OK_COUNT,                   /* count for successfully transmitted RTS frame*/
    TXM_MPDU_RTS_FAIL_COUNT,                 /* count for failed RTS frame*/

    TXM_BMCAST_MPDU_OK_COUNT,                /* B/MCAST MPDU tx ok */
    TXM_UCAST_MPDU_OK_COUNT,                 /* UCAST MPDU tx ok */

    TXM_BMCAST_MPDU_FAIL_COUNT,              /* B/MCAST MPDU tx fail */
    TXM_UCAST_MPDU_FAIL_COUNT,               /* UCAST MPDU tx fail */

    TXM_MPDU_TX_TWICE_OK_COUNT,              /* MPDU retry once and get ACK.
                                                                               * Simulate OID_802_3_XMIT_ONE_COLLISIONS. */

    TXM_MPDU_TX_MORE_TWICE_OK_COUNT,         /* MPDU retry more than once and get ACK.
                                                                               * Simulate OID_802_3_XMIT_MORE_COLLISIONS. */

    TXM_MPDU_ALL_ERR_COUNT,                  /* NOTE: We didn't include the "ATIM not ACK" count.
                                                                               * ALL_ERR = UCAST_FAIL + BMCAST_FAIL */

//  TXM_MPDU_PORT_CTRL_COUNT,                /* ALL_ERR = PORT_CTRL + LIFETIME_ERR + RTS_RETRY_ERR + MPDU_RETRY_ERR */
    TXM_MPDU_LIFETIME_ERR_COUNT,
    TXM_MPDU_RTS_RETRY_ERR_COUNT,
    TXM_MPDU_MPDU_RETRY_ERR_COUNT,

    TXM_MPDU_MPDU_EXCESS_RETRY_ERR_COUNT,    /* MPDU_EXCESS_RETRY_ERR = RTS_RETRY_ERR + MPDU_RETRY_ERR * Simulate OID_802_3_XMIT_MAX_COLLISIONS */
    TXM_MPDU_AGING_TIMEOUT_COUNT,
    TXM_MPDU_PS_OVERFLOW_COUNT,
    TXM_MPDU_MGNT_DROP_COUNT,

    TXM_MPDU_TOTAL_COUNT,                    /* TOTAL == OK + ALL_ERR, didn't count the Retry */
    TXM_MPDU_TOTAL_RETRY_COUNT,              /* TOTAL_RETRY == OK + (ACK Failure Retry) */

//  TXM_BEACON_MMPDU_COUNT,                  /* Beacon tx count */

//  TXM_MSDU_BYTES_COUNT,                    /* MSDU Tx Bytes count */
//  TXM_MSDU_OK_COUNT,
//  TXM_MSDU_FAIL_COUNT,

    TXM_STATISTIC_COUNTER_NUM
} ENUM_TX_STATISTIC_COUNTER_T;
#endif

enum
{
    TXM_DBG_CNT_00 = 0,
    TXM_DBG_CNT_01,
    TXM_DBG_CNT_02,
    TXM_DBG_CNT_03,
    TXM_DBG_CNT_04,
    TXM_DBG_CNT_05,
    TXM_DBG_CNT_06,
    TXM_DBG_CNT_07, /* TX AC counter */
    TXM_DBG_CNT_08,
    TXM_DBG_CNT_09,
    TXM_DBG_CNT_10,
    TXM_DBG_CNT_11,
    TXM_DBG_CNT_NUM
};

typedef enum _ENUM_MSDU_RATE_MODE_T
{
    MSDU_RATE_MODE_AUTO = 0,
    MSDU_RATE_MODE_MANUAL_DESC,
    /* The following rate mode is not implemented by HW yet */
    /* DON'T use!!! */
    MSDU_RATE_MODE_MANUAL_CR
} ENUM_MSDU_RATE_MODE_T;

typedef enum _ENUM_MSDU_OPTION_T
{
    MSDU_OPT_NO_ACK                     = BIT(0),
    MSDU_OPT_NO_AGGREGATE               = BIT(1),
    MSDU_OPT_TIMING_MEASURE             = BIT(2),
    MSDU_OPT_RCPI_NOISE_STATUS          = BIT(3),

    /* Option by Frame Format */
    /* Non-80211 */
    MSDU_OPT_MORE_DATA                  = BIT(4),
    MSDU_OPT_REMOVE_VLAN                = BIT(5),       //Remove VLAN tag if exists

    /* 80211-enhanced */
    MSDU_OPT_AMSDU                      = BIT(6),

    /* 80211-enhanced & Non-80211 */
    MSDU_OPT_EOSP                       = BIT(7),

    /* Beamform */
    MSDU_OPT_NDP                        = BIT(8),
    MSDU_OPT_NDPA                       = BIT(9),
    MSDU_OPT_SOUNDING                   = BIT(10),

    /* Protection */
    MSDU_OPT_FORCE_RTS                  = BIT(11),

    /* Security */
    MSDU_OPT_BIP                        = BIT(12),
    MSDU_OPT_PROTECTED_FRAME            = BIT(13),

    /* SW Field */
    MSDU_OPT_SW_DURATION                = BIT(14),
    MSDU_OPT_SW_PS_BIT                  = BIT(15),
    MSDU_OPT_SW_HTC                     = BIT(16),
    MSDU_OPT_SW_BAR_SN                  = BIT(17),

    /* Manual Mode */
    MSDU_OPT_MANUAL_FIRST_BIT           = BIT(18),

    MSDU_OPT_MANUAL_LIFE_TIME           = MSDU_OPT_MANUAL_FIRST_BIT,
    MSDU_OPT_MANUAL_RETRY_LIMIT         = BIT(19),
    MSDU_OPT_MANUAL_POWER_OFFSET        = BIT(20),
    MSDU_OPT_MANUAL_TX_QUE              = BIT(21),
    MSDU_OPT_MANUAL_SN                  = BIT(22),
    MSDU_OPT_MANUAL_EMQ_REVERSE         = BIT(23),

    MSDU_OPT_MANUAL_LAST_BIT            = MSDU_OPT_MANUAL_SN
} ENUM_MSDU_OPTION_T;

typedef enum _ENUM_MSDU_CONTROL_FLAG_T
{
    MSDU_CONTROL_FLAG_NOT_BUFFERED      = BIT(0),
    MSDU_CONTROL_FLAG_KEEP_MSDU_INFO    = BIT(1),
    MSDU_CONTROL_FLAG_ENQUEUE_TO_MAC    = BIT(2),
} ENUM_MSDU_CONTROL_FLAG_T;

typedef struct _BEACON_INFO_T
{
    BOOLEAN         fgIsInUse;
    P_MSDU_INFO_T   prMsduInfo;
} BEACON_INFO_T, *P_BEACON_INFO_T;

#define NIC_BCN_NUM                     2

typedef struct _TXM_T
{
    /* CMD/MSDU_INFO timer */
    RALINK_TIMER_STRUCT         rTxHifMsduTimer;
    RALINK_TIMER_STRUCT         rTxHifCmdTimer;
    LINK_T          rTxHifCmdList;

    UINT_32         u4FlagBitmap;

    /* AC queue operation is per-OWN_MAC basis, but BCN/BMC is per-BSSID */
    /* It must reserve enough space for SW queue status record structure */

    /* To remember the status of MAC TX queues
     * Possible status:  STARTED = 0, STOPPED = 1
     * One bits are designated for each queue (AC0~AC6, BCN, BMC, AC10~14).
     */
    UINT_16         au2MacTxQueueStateBitmap[MAC_ADDR_NUM];

    /* SW queues: AC5 and AC6 link lists
     * Note that SW queues for data AC0~AC3 are placed in STA_RECs
     * SW queues for BMC and beacon are placed in BSS_INFO
     */
    LINK_T          rAC6PktList;

    /* Max buffer for STA when STA is in PS or use it in normal mode in future */
    /* if the value is changed, the evnet should be sent to DRV to update it */
    UINT_8          ucMaxBufferPerSta;

    /* Global PID pool, for Tx status and MSDU_INFO mapping */
    /* FW side availiable range: 128 ~ 255 */
    UINT_8          aucPidPool[MAX_WTBL_ENTRY_NUM];

    /* SW queue: Txing packet link list */
    /* Get original MSDU_INFO for Tx done requirement */
    LINK_T          rTxingPktList;

#if CFG_CMD_GET_STATISTIC
    UINT_64         au8Statistics[TXM_STATISTIC_COUNTER_NUM]; /* TX Counters */
#endif

#if CFG_SLT_SUPPORT && 0
    UINT_16         u2FixedRateCode;
#endif

#if TXM_DBG_COUNTER
    UINT_32         au4DebugCounters[TXM_DBG_CNT_NUM]; /* TX Counters */
#endif

    /* Beacon pool for AP-mode BSS */
    BEACON_INFO_T   arBcnPool[NIC_BCN_NUM];
} TXM_T, *P_TXM_T;

/* This enum is used for filling MAC TX Desc when fixed transmit rate is used */
typedef enum _ENUM_TX_FIXED_RATE_BW_T
{
    TX_FIXED_RATE_BW_NOT_FIXED = 0, /* The BW is determined according to the PCO mechanism */
    TX_FIXED_RATE_BW_RESERVED,
    TX_FIXED_RATE_BW_20M_IN_40M,
    TX_FIXED_RATE_BW_40M_IN_40M
} ENUM_TX_FIXED_RATE_BW_T;

/* The operating BW for TX */
typedef enum _ENUM_TX_OPERATING_BW_T
{
    TX_OPERATING_BW_20M,
    TX_OPERATING_BW_40M
} ENUM_TX_OPERATING_BW_T;

/* Types(reasons or goals) of queue operations */
typedef enum _ENUM_FLUSH_QUEUE_REASON_T     /* Flush means Clean-up and stop */
{
    FLUSH_QUEUE_REASON_RF_TEST,
    FLUSH_QUEUE_REASON_PS_MODE_CHANGE,
    FLUSH_QUEUE_REASON_BEACON_UPDATE,
    FLUSH_QUEUE_REASON_SCAN_INIT,
    FLUSH_QUEUE_REASON_DELBA,
    FLUSH_QUEUE_REASON_BSS_ABSENCE,
    FLUSH_QUEUE_REASON_STA_ENTER_PS,
    FLUSH_QUEUE_REASON_BSS_DISCONNECT,
    FLUSH_QUEUE_REASON_STA_DISCONNECT,
    FLUSH_QUEUE_REASON_RESTART_BMC_Q,
    FLUSH_QUEUE_REASON_REENQUEUE,
    FLUSH_QUEUE_REASON_NUM
} ENUM_FLUSH_QUEUE_REASON_T;

typedef enum _ENUM_PAUSE_QUEUE_REASON_T
{
    PAUSE_QUEUE_REASON_SCAN_START,
    PAUSE_QUEUE_REASON_NUM
} ENUM_PAUSE_QUEUE_REASON_T, *P_ENUM_PAUSE_QUEUE_REASON_T;

typedef enum _ENUM_RESUME_QUEUE_REASON_T
{
    RESUME_QUEUE_REASON_SCAN_END,
    RESUME_QUEUE_REASON_NUM
} ENUM_RESUME_QUEUE_REASON_T, *P_ENUM_RESUME_QUEUE_REASON_T;

/* Parameters for flushing a TX queue */
typedef struct _FLUSH_QUEUE_REQUEST_T
{
    UINT_32 au4Params[3]; /* Varies with the flush queue type */
    ENUM_FLUSH_QUEUE_REASON_T eFlushQueueReason;
    ENUM_HW_TX_QUE_T eQueIdx;
    UINT_16 u2QueIdxBitmap;
} FLUSH_QUEUE_REQUEST_T, *P_FLUSH_QUEUE_REQUEST_T;

/* Parameters for stopping a TX queue */
typedef struct _PAUSE_QUEUE_REQUEST_T
{
    ENUM_PAUSE_QUEUE_REASON_T ePauseQueueReason;
    ENUM_HW_TX_QUE_T eQueIdx;
} PAUSE_QUEUE_REQUEST_T, *P_PAUSE_QUEUE_REQUEST_T;

/* Parameters for resuming a TX queue (in case all active TX queues need to be resumed, use txmStartMacTxDma() */
typedef struct _RESUME_QUEUE_REQUEST_T
{
    ENUM_RESUME_QUEUE_REASON_T  eResumeQueueReason;
    ENUM_HW_TX_QUE_T   eQueIdx;
} RESUME_QUEUE_REQUEST_T, *P_RESUME_QUEUE_REQUEST_T;

typedef enum _ENUM_FREE_QUOTA_MODET_T
{
    FREE_QUOTA_UPDATE_MODE_INIT = 0,
    FREE_QUOTA_UPDATE_MODE_OVERWRITE,
    FREE_QUOTA_UPDATE_MODE_INCREASE,
    FREE_QUOTA_UPDATE_MODE_DECREASE
} ENUM_FREE_QUOTA_MODET_T, *P_ENUM_FREE_QUOTA_MODET_T;

typedef enum _ENUM_TX_RESULT_CODE_T
{
    TX_RESULT_CODE_SUCCESS = 0,
    TX_RESULT_CODE_LIFE_TIMEOUT,
    TX_RESULT_CODE_RTS_ERROR,
    TX_RESULT_CODE_MPDU_ERROR,
    TX_RESULT_CODE_AGING_TIMEOUT,
    TX_RESULT_CODE_FLUSHED,
    TX_RESULT_CODE_BIP_ERROR,
    TX_RESULT_CODE_UNSPECIFIED_ERROR,
    TX_RESULT_CODE_DROPPED_IN_DRIVER = 32,
    TX_RESULT_CODE_DROPPED_IN_FW,
    TX_RESULT_CODE_NUM
} ENUM_TX_RESULT_CODE_T, *P_ENUM_TX_RESULT_CODE_T;

typedef struct _WLAN_STATUS_TO_TX_RESULT_T
{
    WLAN_STATUS rWlanStatus;
    UINT_8 ucTxResult;
} WLAN_STATUS_TO_TX_RESULT_T, *P_WLAN_STATUS_TO_TX_RESULT_T;

typedef struct _EVENT_TX_DONE_T
{
    /* Event header */
    UINT_16     u2Length;
    UINT_16     u2Reserved1;    /* Must be filled with 0x0001 (EVENT Packet) */
    UINT_8      ucEID;
    UINT_8      ucSeqNum;
    UINT_8      aucReserved2[2];

    /* Event Body */
    UINT_8      ucPacketSeq;
    UINT_8      ucStatus;
    UINT_16     u2SequenceNumber;
    UINT_8      ucWlanIndex;
    UINT_8      aucReserved1[3];
    UINT_32     au4Reserved2;
    UINT_32     au4Reserved3;
} EVENT_TX_DONE_T, *P_EVENT_TX_DONE_T;

typedef struct _EVENT_BSS_ABSENCE_PRESENCE_T
{
    /* Event header */
    UINT_16     u2Length;
    UINT_16     u2Reserved1;    /* Must be filled with 0x0001 (EVENT Packet) */
    UINT_8      ucEID;
    UINT_8      ucSeqNum;
    UINT_8      aucReserved2[2];

    /* Event Body */
    UINT_8      ucBssIndex;
    UINT_8      ucIsAbsent;
    UINT_8      ucBssFreeQuota;
    UINT_8      aucReserved[1];
} EVENT_BSS_ABSENCE_PRESENCE_T, *P_EVENT_BSS_ABSENCE_PRESENCE_T;

typedef struct _EVENT_STA_CHANGE_PS_MODE_T
{
    /* Event header */
    UINT_16     u2Length;
    UINT_16     u2Reserved1;    /* Must be filled with 0x0001 (EVENT Packet) */
    UINT_8      ucEID;
    UINT_8      ucSeqNum;
    UINT_8      aucReserved2[2];

    /* Event Body */
    UINT_8      ucStaRecIdx;
    UINT_8      ucIsInPs;
    UINT_8      ucUpdateMode;
    UINT_8      ucFreeQuota;
} EVENT_STA_CHANGE_PS_MODE_T, *P_EVENT_STA_CHANGE_PS_MODE_T;

/* The free quota is used by PS only now */
/* The event may be used by per STA flow conttrol in general */
typedef struct _EVENT_STA_UPDATE_FREE_QUOTA_T
{
    /* Event header */
    UINT_16     u2Length;
    UINT_16     u2Reserved1;    /* Must be filled with 0x0001 (EVENT Packet) */
    UINT_8      ucEID;
    UINT_8      ucSeqNum;
    UINT_8      aucReserved2[2];

    /* Event Body */
    UINT_8      ucStaRecIdx;
    UINT_8      ucUpdateMode;
    UINT_8      ucFreeQuota;
    UINT_8      aucReserved[1];
} EVENT_STA_UPDATE_FREE_QUOTA_T, *P_EVENT_STA_UPDATE_FREE_QUOTA_T;

/*******************************************************************************
*                            P U B L I C   D A T A
********************************************************************************
*/
extern TXM_T g_rTxm;
extern P_TXM_T g_prTxm;

/*******************************************************************************
*                           P R I V A T E   D A T A
********************************************************************************
*/

/*******************************************************************************
*                                 M A C R O S
********************************************************************************
*/
#if TXM_DBG_COUNTER
#define TXM_DBG_CNT_INC(_index) {g_prTxm->au4DebugCounters[(_index)]++;}
#define TXM_DBG_CNT_SET(_index,_value) {g_prTxm->au4DebugCounters[(_index)] = _value;}
#else
#define TXM_DBG_CNT_INC(_index) {}
#define TXM_DBG_CNT_SET(_index,_value) {}
#endif

#if (CFG_CMD_GET_STATISTIC == 1)
#define TXM_INC_CNT(eCounter) {g_prTxm->au8Statistics[eCounter]++;}
#define TXM_ADD_CNT(eCounter, u8Amount) {g_prTxm->au8Statistics[eCounter] += (UINT_64)u8Amount;}
#define TXM_GET_CNT(eCounter) (g_prTxm->au8Statistics[eCounter])
#define TXM_RESET_ALL_CNTS() {kalMemZero(&g_prTxm->au8Statistics[0], sizeof(g_prTxm->au8Statistics));}
#else
#define TXM_INC_CNT(eCounter)
#define TXM_ADD_CNT(eCounter, u8Amount)
#define TXM_GET_CNT(eCounter)
#define TXM_RESET_ALL_CNTS()
#endif

/* Macros for manipulating TXM internal flags */
#define TXM_SET_FLAG(_flag) {(g_prTxm->u4FlagBitmap) |= (BIT((_flag)));}
#define TXM_CLEAR_FLAG(_flag) {(g_prTxm->u4FlagBitmap) &= (~ BIT((_flag)));}
#define TXM_CHECK_FLAG(_flag) ((g_prTxm->u4FlagBitmap) & (BIT((_flag))))

#define TXM_IS_NORMAL_802_11_FRAME(_prMsduInfo) \
    (((_prMsduInfo)->ucHeaderFormat == HEADER_FORMAT_802_11_NORMAL_MODE)?TRUE:FALSE)

#define TXM_IS_NATIVE_802_11_FRAME(_prMsduInfo) \
    (((_prMsduInfo)->ucHeaderFormat == HEADER_FORMAT_802_11_ENHANCE_MODE)?TRUE:FALSE)

#define TXM_IS_ETHERNET_802_3_FRAME(_prMsduInfo) \
    (((_prMsduInfo)->ucHeaderFormat == HEADER_FORMAT_NON_802_11)?TRUE:FALSE)

#define TXM_IS_802_11_FRAME(_prMsduInfo) \
    (TXM_IS_NORMAL_802_11_FRAME(_prMsduInfo) || TXM_IS_NATIVE_802_11_FRAME(_prMsduInfo))

#define TXM_IS_STATUS_AVAILABLE(_prMsduInfo) \
    (_prMsduInfo->prTxStatus)

#define TXM_IS_WLAN_MAC_HEADER_AVAILABLE(_prMsduInfo) \
    ((_prMsduInfo->fgIs802_11Frame) == TRUE && !TXM_IS_STATUS_AVAILABLE(_prMsduInfo))

/* This macro shall only be called for data frames */
#define TXM_IS_QOS_ENABLED_DATA(_prMsduInfo) \
    (((_prMsduInfo)->prStaRec)?((((_prMsduInfo)->prStaRec)->ucIsQosLink)): FALSE)

/* (Check FC bits#2-3) Bit#2 == 0 && Bit#3 == 1 means Data frame */
#define TXM_IS_DATA_FRAME(_prPkt) \
    ((TXM_IS_WLAN_MAC_HEADER_AVAILABLE(_prPkt)) \
        ? ( (((*((_prPkt)->pucMacHeader)) & MASK_FC_TYPE) == MAC_FRAME_TYPE_DATA)? TRUE: FALSE)\
        : ((_prPkt->ucPacketType == TX_PKT_TYPE_DATA) ? TRUE : FALSE))

/* (Check FC bits#2-3) Bit#2 == 0 && Bit#3 == 0 means MNG frame */
#define TXM_IS_MNG_FRAME(_prPkt) \
    ((TXM_IS_WLAN_MAC_HEADER_AVAILABLE(_prPkt)) \
        ? ( (((*((_prPkt)->pucMacHeader)) & MASK_FC_TYPE) == MAC_FRAME_TYPE_MGT)? TRUE: FALSE)\
        : FALSE)

/* (Check FC bits#2-3) Bit#2 == 1 && Bit#3 == 0 means CTRL frame */
#define TXM_IS_CTRL_FRAME(_prPkt) \
    ((TXM_IS_WLAN_MAC_HEADER_AVAILABLE(_prPkt)) \
        ? ( (((*((_prPkt)->pucMacHeader)) & MASK_FC_TYPE) == MAC_FRAME_TYPE_CTRL)? TRUE: FALSE)\
        : FALSE)

/* (Check FC bits#2-7) Bit#2 == 0 && Bit#3 == 1 && Bit#7 = 1 means QoS Data frame */
#define TXM_IS_QOS_DATA_FRAME(_prPkt) \
    ((TXM_IS_WLAN_MAC_HEADER_AVAILABLE(_prPkt)) \
        ? ( (((*((_prPkt)->pucMacHeader)) & MASK_FRAME_TYPE) == MAC_FRAME_QOS_DATA)? TRUE: FALSE)\
        : (TXM_IS_QOS_ENABLED_DATA(_prPkt)))

#define TXM_IS_BMCAST_FRAME(_prMsduInfo) \
    ((TXM_IS_WLAN_MAC_HEADER_AVAILABLE(_prMsduInfo)) \
        ? (IS_BMCAST_MAC_ADDR(((P_WLAN_MAC_HEADER_T)((_prMsduInfo)->pucMacHeader))->aucAddr1))\
        : ((_prMsduInfo->prStaRec == NULL) ? TRUE : FALSE))

#define TXM_IS_UCAST_FRAME(_prMsduInfo) \
    (!TXM_IS_BMCAST_FRAME((_prMsduInfo)))

#define TXM_NEED_TX_DONE(_prMsduInfo) \
    ((_prMsduInfo)->pfTxDoneHandler || (_prMsduInfo)->pfTxDoneHandlerPs)

#define TXM_SET_MAC_TX_QUEUE_STATUS(_eQueIdx, _ucMacIdx, _eStatus) \
    { \
        if(_eStatus == MAC_TX_QUEUE_STATUS_STARTED) { \
            ((g_prTxm->au2MacTxQueueStateBitmap[(_ucMacIdx)]) &= ~BIT(_eQueIdx)); \
        } \
        else { \
            ((g_prTxm->au2MacTxQueueStateBitmap[(_ucMacIdx)]) |= BIT(_eQueIdx)); \
        } \
    }

#define TXM_GET_MAC_TX_QUEUE_STATUS(_eQueIdx, _ucMacIdx) \
    ((ENUM_MAC_TX_QUEUE_STATUS_T)(((g_prTxm->au2MacTxQueueStateBitmap[_ucMacIdx]) >> \
    ((UINT_32)(_eQueIdx)))) & BIT(0))

#define TXM_ALL_TX_Q_BITMAP \
    BITS(TX_Q_AC0, TX_Q_AC14)

#define TXM_DATA_TX_Q_BITMAP \
    BITS(TX_Q_AC0, TX_Q_AC4) | BITS(TX_Q_AC10, TX_Q_AC14) | BIT(TX_Q_BMC)

#define TXM_MGMT_BUFFERED_TX_Q_BITMAP \
    BIT(TX_Q_AC4) | BIT(TX_Q_AC14) | BIT(TX_Q_BCN) | BIT(TX_Q_BMC)

#define COPY_6_BYTE_FIELD(_pucDestAddr, _pucSrcAddr) \
    (NdisCopyMemory((_pucDestAddr), (_pucSrcAddr), 6))

/*
 * MSB                  -->                 LSB
 *                    SN                     FragNum
 *   0 0 0 0   0 0 0 0   0 0 0 0  X X X X
 */
#define COPY_SEQUENCE_NUMBER(_uc2SN, _prMsduInfo) \
    { \
        *((PUINT_16)(((_prMsduInfo)->pucMacHeader)+22)) &= (~MASK_SC_FRAG_NUM); \
        *((PUINT_16)(((_prMsduInfo)->pucMacHeader)+22)) |= ((_uc2SN) << MASK_SC_SEQ_NUM_OFFSET);\
    }

#define RETRIEVE_SEQUENCE_NUMBER(_prMsduInfo) \
    ((*((PUINT_16)(((_prMsduInfo)->pucMacHeader)+22))) >> MASK_SC_SEQ_NUM_OFFSET)


#define TXM_GET_MAC_TX_QUEUE_LENGTH() \
    ((CFG_NUM_OF_MAC_TX_DESC - HW_TX_QUE_NUM) - halMacTxGetFreeDescNum(g_prHalTxCtrl))

#define TX_STATUS_IS_TX_FAILED(_prHwMacTxStatus) \
            (HAL_MAC_TX_STATUS_IS_MPDU_ERROR(_prHwMacTxStatus) || \
             HAL_MAC_TX_STATUS_IS_RTS_ERROR(_prHwMacTxStatus) || \
             HAL_MAC_TX_STATUS_IS_LIFETIME_ERROR(_prHwMacTxStatus) || \
             HAL_MAC_TX_STATUS_IS_BIP_ERROR(_prHwMacTxStatus))

/* For txmSetDefaultRate() definition */
#define TXM_CCK_RATENUM  4
#define TXM_OFDM_RATENUM 8
#define TXM_HT_RATENUM   32
#define TXM_VHT_RATENUM  10


#if 0 //IOT_PROCESS_PORTING
/* We still need this table if the RA is not off load */
#if (CFG_WIFI_DRIVER_OFFLOAD_RATE_CTRL == 0)
typedef struct _RA_ENTRY_INFO_T {
    UCHAR   ucSupportRateMode;
    UINT_8  ucSupportCCKMCS;
    UINT_8  ucSupportOFDMMCS;
    UINT_32 u4SupportHTMCS;
    UINT_16 u2SupportVHTMCS1SS;
}RA_ENTRY_INFO_T, *P_RA_ENTRY_INFO_T;
#endif/*IOT_PROCESS_PORTING*/
#endif

/*******************************************************************************
*                   F U N C T I O N   D E C L A R A T I O N S
********************************************************************************
*/
VOID
txmInit(
    VOID
    );

VOID
txmProtectionInit(
    VOID
    );

VOID
txmTestDumpPseStatus(
    VOID
    );

VOID
txmSetHifDescTemplate(
    UINT_32 u4RemainingTxTimeInMs,
    UINT_8  ucRemainingTxCount,
    UINT_8  ucPacketId,
    BOOLEAN fgDisableAMPDU,
    BOOLEAN fgDAFromWtblPA,
    BOOLEAN fgRCPIStatus,
    BOOLEAN fgStatus2Host,
    BOOLEAN fgStatus2Mcu
    );

VOID
txmHifMsduTimeout(
    UINT_32     u4Data
    );

VOID
txmHifCmdTimeout(
    UINT_32     u4Data
    );

UINT_8
txmGetOwnMacIdxByBssidIdx(
    UINT_8 ucBssidIdx
    );

VOID
txmSendHifPackets(
    IN P_MSDU_INFO_T prMsduInfoListHead
    );

VOID
txmSendDataPackets(
    IN P_MSDU_INFO_T prMsduInfoListHead
    );

VOID
txmSendMngPackets(
    IN P_MSDU_INFO_T prMsduInfoListHead
    );

VOID
txmFreePkt(
    IN P_MSDU_INFO_T prMsduInfo,
    IN BOOLEAN  fgFreeBuf,
    IN WLAN_STATUS rWlanStatus
    );

#if 0 //IOT_PROCESS_PORTING
VOID
txmTranslateHeader(
    IN P_MSDU_INFO_T prMsduInfo,
    IN P_HIF_TX_HEADER_T prHifTxHeader
    );
#endif
VOID
txmBufferPacket(
    IN P_MSDU_INFO_T prMsduInfo
    );

BOOLEAN
txmGetPmTxDoneRequirement(
    IN P_MSDU_INFO_T prMsduInfo
    );

VOID
txmForwardPktToMacTxDma(
    IN P_MSDU_INFO_T prMsduInfo
    );

VOID
txmHandleMacTxDone(
    P_HW_MAC_TX_STATUS_T prTxStatus
    );

VOID
txmPsForwardingStatusUpdate(
    IN P_MSDU_INFO_T prMsduInfo,
    IN P_HW_MAC_TX_DESC_T prTxDesc
    );

VOID
txmPsForwardingControlTxDoneCheck(
    IN P_MSDU_INFO_T prMsduInfo
    );

VOID
txmPauseQueue(
    IN ENUM_PAUSE_QUEUE_REASON_T ePauseQueueReason,
    IN UINT_32 u4QueIdxBitmap
    );

VOID
txmResumeQueue(
    IN ENUM_RESUME_QUEUE_REASON_T eResumeQueueReason,
    IN UINT_32 u4QueIdxBitmap
    );

#if 0
WLAN_STATUS
(*txmFilterQueue)(
    IN UINT_32                      u4QueIdxBitmap,
    IN ENUM_MAC_QUEUE_FILTER_MODE_T eFilterMode,
    IN UINT_32                      u4Param1
    );
#endif
VOID
txmFlushQueueByOwnMac(
    IN ENUM_FLUSH_QUEUE_REASON_T    eFlushQueueReason,
    IN UINT_32                      u4QueIdxBitmap,
    IN UINT_8                       ucMacIdx
    );

VOID
txmFlushQueueByWlanIdx(
    IN ENUM_FLUSH_QUEUE_REASON_T    eFlushQueueReason,
    IN UINT_32                      u4QueIdxBitmap,
    IN UINT_8                       ucWtblIdx,
    IN UINT_8                       ucMacIdx
    );

VOID
txmFlushBcnQueue(
    IN UINT_8                       ucHwBssidIdx
    );

VOID
txmFlushQueueToDiscard(
    IN ENUM_FLUSH_QUEUE_REASON_T   eFlushQueueReason,
    IN UINT_32                     u4QueIdxBitmap,
    IN UINT_32                     u4Param1
    );

VOID
txmFlushQueueToDefer(
    IN ENUM_FLUSH_QUEUE_REASON_T   eFlushQueueReason,
    IN UINT_32                     u4QueIdxBitmap,
    IN UINT_32                     u4Param1
    );

VOID
txmFlushQueueToModify(
    IN ENUM_FLUSH_QUEUE_REASON_T   eFlushQueueReason,
    IN UINT_32                     u4QueIdxBitmap,
    IN UINT_32                     u4Param1,
    IN UINT_32                     u4Param2
    );

extern VOID
(*txmStartQueue)(
    IN UINT_32 u4QueIdxBitmap,
    IN UINT_8 ucOwnMacIdx
    );

extern VOID
(*txmStopQueue)(
    IN UINT_32 u4QueIdxBitmap,
    IN UINT_8 ucOwnMacIdx,
    IN BOOLEAN fgAbort
    );

UINT_32
txmDetermineWlanIdx(
    IN P_MSDU_INFO_T prMsduInfo
    );

VOID
txmInitStaRec(
    P_STA_RECORD_T prStaRec
    );

VOID
txmUpdateBssTxParams(
    IN P_BSS_INFO_T prBssInfo
    );

VOID
txmUpdateStaRecTxParams(
    IN P_STA_RECORD_T prStaRec
    );

VOID
txmInitDefaultWtblTxParams(
    IN UINT_8 ucEntry
    );

VOID
txmInitBmcWtblTxParams(
    IN P_BSS_INFO_T prBssInfo,
    IN UINT_8 ucEntry
    );

VOID
txmInitStaWtblTxParams(
    IN P_STA_RECORD_T prStaRec
    );

VOID
txmIndicateStaConnected(
    IN  P_STA_RECORD_T prStaRec
    );

VOID
txmHandleDisconnectionEvent(
    IN P_STA_RECORD_T prStaRec
    );

BOOLEAN
txmHasBufferedPktsInSw(
    VOID
    );

VOID
txmSetMediumAccessRestriction(
    IN BOOLEAN fgAdmissionControlEnabled,
    IN UINT_16 u2AdmitTime,
    IN UINT_8 ucAdmitPeriod
    );

VOID
txmForwardBufferedPktsToMacTxDMA(
    P_LINK_T prPacketList
    );

WLAN_STATUS
txmDummyTxDone(
    IN P_MSDU_INFO_T prMsduInfo,
    IN WLAN_STATUS rTxDoneStatus
    );

WLAN_STATUS
txmSendTxDoneEvent(
    IN P_MSDU_INFO_T prMsduInfo,
    IN WLAN_STATUS rTxDoneStatus
    );

BOOLEAN
txmIndicateBssAbsenseToFW(
    IN UINT_8 ucBssIndex
    );

BOOLEAN
txmIndicateBssPresenseToFW(
    IN UINT_8 ucBssIndex
    );

BOOLEAN
txmIndicateBssAbsenseToHost(
    IN UINT_8 ucBssIndex
    );

BOOLEAN
txmIndicateBssPresenseToHost(
    IN UINT_8 ucBssIndex
    );

BOOLEAN
txmIndicateBssAbsense(
    IN UINT_8 ucBssIndex
    );

BOOLEAN
txmIndicateBssPresense(
    IN UINT_8 ucBssIndex
    );

VOID
txmHandleBssDisconnectionEvent(
    IN UINT_8 ucBssIndex
    );

VOID
txmHandleBssActivate(
    IN UINT_8 ucBssIndex,
    IN BOOLEAN fgActivate
    );

UINT_8
txmGetStaPktWaitInHwQueCnt(
    P_STA_RECORD_T prStaRec,
    UINT_8 ucTxQueIdx
    );

BOOLEAN
txmIncreaseStaPktBufferedCnt(
    P_MSDU_INFO_T prMsduInfo
    );

BOOLEAN
txmDecreaseStaPktBufferedCnt(
    P_MSDU_INFO_T prMsduInfo
    );

UINT_8
txmGetStaPktBufferedCnt(
    P_STA_RECORD_T prStaRec
    );

#if 0
VOID
(*txmSetWtblSkipTxBit)(
    UINT_8          ucEntry,
    BOOLEAN         fgEnableTx
    );
#endif
VOID
txmSetWlanIdxTxRedirection(
    UINT_8          ucWTEntry,
    BOOLEAN         fgEnable
    );

VOID
txmProcessHifTxPackets (
    ENUM_PSE_CPU_P_QUEUE_T  eCqID
    );

VOID
txmSetStaPsBit(
    IN P_STA_RECORD_T prStaRec,
    BOOLEAN fgIsPs
    );

VOID
txmSendBufferedPacket(
    VOID
    );

VOID
txmForwardFlushedPktsToMacTxDMA(
    P_MSDU_INFO_T prMsduInfoListHead
    );

WLAN_STATUS
txmSendBssStatusEvent(
    IN UINT_8  ucBssIndex,
    IN BOOLEAN fgIsAbsent
    );

VOID
txmSetRedirection(
    IN UINT_8 ucWTEntry,
    IN BOOLEAN fgEnable
    );

VOID
txmStaHandlePsModeChange(
    IN P_BSS_INFO_T prBssInfo,
    IN BOOLEAN fgIsPs
    );

VOID
txmStaHandleRedirection(
    P_STA_RECORD_T prStaRec,
    BOOLEAN fgEnable
    );

BOOLEAN
txmApSetStaTxBufferFunc(
    IN P_STA_RECORD_T prStaRec,
    IN BOOLEAN fgEnableBuffer
    );

VOID
txmApSetBmcTxBufferFunc(
    IN P_BSS_INFO_T     prBssInfo,
    IN BOOLEAN          fgEnableBuffer
    );

VOID
txmApSendStaBufferedPacket(
    IN P_STA_RECORD_T prStaRec
    );

WLAN_STATUS
txmApSendStaPsModeEvent(
    IN UINT_8  ucStaRecIdx,
    IN BOOLEAN fgIsInPs
    );

WLAN_STATUS
txmApSendStaFreeQuotaEvent(
    IN UINT_8 ucStaRecIdx,
    IN UINT_8 ucUpdateMode,
    IN UINT_8 ucFreeQuota
    );

VOID
txmApSendDelayedFreeQuotaEvent(
    UINT_8 ucBssIndex
    );

WLAN_STATUS
txmApCheckStaFreeQuota(
    P_STA_RECORD_T prStaRec
    );

WLAN_STATUS
txmApCallbackBufferedPktSent(
    P_MSDU_INFO_T prMsduInfo,
    WLAN_STATUS rWlanStatus
    );

WLAN_STATUS
txmApCallbackBufferedPktSentByPsPoll(
    P_MSDU_INFO_T prMsduInfo,
    WLAN_STATUS rWlanStatus
    );

VOID
txmApSendBufferedBmcPkts(
    IN UINT_8 ucBssIndex
    );

VOID
txmApHandleBufferedBmcPkts(
    IN P_BSS_INFO_T prBssInfo,
    IN BOOLEAN fgIsDTIM
    );

BOOLEAN
txmApHasBufferedBmcPackets(
    UINT_8 ucBssIndex
    );

BOOLEAN
txmApHasBufferedUcPackets(
    P_STA_RECORD_T prStaRec,
    UINT_32  u4BmpTxQueue,
    UINT_32  u4Flags
    );

UINT_8
txmApGetPrevUcPacketTxQueByPsPoll(
    IN P_STA_RECORD_T prStaRec
    );

BOOLEAN
txmApTriggerUcPacketByPsPoll(
    IN P_STA_RECORD_T prStaRec,
    IN UINT_32        u4BmpBufferAC
    );

BOOLEAN
txmApTriggerUcPacketByTriggerFrame(
    IN P_STA_RECORD_T prStaRec,
    IN UINT_32        u4BmpBufferAC,
    IN UINT_32        u4MaxNumOfPkt
    );

VOID
txmApUpdateMoreDataBit(
    IN P_STA_RECORD_T prStaRec,
    IN P_MSDU_INFO_T  prCurrentMsduInfo
    );

UINT_32
txmApGetBufferedUcPacketCnt(
    P_STA_RECORD_T prStaRec,
    UINT_32        u4BmpTxQueue
    );

VOID
txmApRemoveAgingPktsBySta(
    P_STA_RECORD_T  prStaRec,
    UINT_32         u4AgingTimeInMs,
    OS_SYSTIME      rCurrentSysTime
    );

VOID
txmApRemoveAgingPkts(
    UINT_8 ucBssIndex
    );

UINT_32
txmACIBmpToACBmp(
    P_STA_RECORD_T prStaRec,
    UINT_8         ucBmpACI
    );

VOID
txmSetMngPacket(
    P_MSDU_INFO_T           prMsduInfo,
    P_STA_RECORD_T          prStaRec,
    P_UINT_8                pucMacHeader,
    UINT_8                  ucMacHeaderLength,
    P_UINT_8                pucPayload,
    UINT_16                 u2PayloadLength,
    PFN_TX_DONE_HANDLER     pfTxDoneHandler,
    UINT_8                  ucRateMode,
    P_MSDU_INFO_T           prNextMsduInfo
    );

VOID
txmSetDataPacket(
    P_MSDU_INFO_T           prMsduInfo,
    P_STA_RECORD_T          prStaRec,
    UINT_8                  ucBssIndex,
    P_UINT_8                pucMacHeader,
    UINT_8                  ucMacHeaderLength,
    P_UINT_8                pucPayload,
    UINT_16                 u2PayloadLength,
    PFN_TX_DONE_HANDLER     pfTxDoneHandler,
    UINT_8                  ucRateMode,
    UINT_8                  ucTID,
    UINT_8                  ucHeaderFormat
    );

P_MSDU_INFO_T
txmAllocPkt(
    UINT_32 u4PacketLength
    );

PUINT_8
txmGetPktBuffer(
    P_MSDU_INFO_T prMsduInfo
    );

PUINT_8
txmGetPktBufferInPse(
    PUINT_8     pucPseBuffer
    );

P_MSDU_INFO_T
txmAllocBcnPkt(
    UINT_32         u4EstimateLength
    );

BOOLEAN
txmResetBcnPkt(
    P_MSDU_INFO_T   prMsduInfo
    );

VOID
txmFreeBcnPkt(
    P_MSDU_INFO_T   prMsduInfo
    );

VOID
txmFreePseFrame(
    UINT_16 u2Fid
    );

VOID
txmConfigPktOption(
    P_MSDU_INFO_T   prMsduInfo,
    UINT_32         u4OptionMask,
    BOOLEAN         fgSetOption
    );

VOID
txmConfigPktControlFlag(
    P_MSDU_INFO_T   prMsduInfo,
    UINT_8          ucControlFlagMask,
    BOOLEAN         fgSetFlag
    );

VOID
txmSetPktLifeTime(
    P_MSDU_INFO_T   prMsduInfo,
    UINT_32         u4TxLifeTimeInMs
    );

VOID
txmSetPktRetryLimit(
    P_MSDU_INFO_T   prMsduInfo,
    UINT_8          ucRetryLimit
    );

VOID
txmSetPktPowerOffset(
    P_MSDU_INFO_T   prMsduInfo,
    INT_8           cPowerOffset
    );

VOID
txmSetPktSequenceNumber(
    P_MSDU_INFO_T   prMsduInfo,
    UINT_16         u2SN
    );

VOID
txmSetPktMacTxQue(
    P_MSDU_INFO_T   prMsduInfo,
    UINT_8          ucMacTxQue
    );

VOID
txmSetPktMoreData(
    P_MSDU_INFO_T   prCurrentMsduInfo,
    BOOLEAN fgSetMoreDataBit
    );

BOOLEAN
txmEnqueuePacket(
    P_MSDU_INFO_T prMsduInfo
    );

VOID
txmSetPktEOSP(
    P_MSDU_INFO_T   prCurrentMsduInfo,
    BOOLEAN fgSetEOSPBit
    );

VOID
txmSetPktFixedRateOptionFull(
    P_MSDU_INFO_T   prMsduInfo,
    UINT_16         u2RateCode,
    UINT_8          ucBandwidth,
    BOOLEAN         fgShortGI,
    BOOLEAN         fgLDPC,
    BOOLEAN         fgDynamicBwRts,
    BOOLEAN         fgSpatialExt,
    BOOLEAN         fgEtxBeamforming,
    BOOLEAN         fgItxBeamforming,
    UINT_8          ucAntennaIndex,
    UINT_8          ucAntennaPriority
    );

VOID
txmSetPktFixedRateOption(
    P_MSDU_INFO_T   prMsduInfo,
    UINT_16         u2RateCode,
    UINT_8          ucBandwidth,
    BOOLEAN         fgShortGI,
    BOOLEAN         fgDynamicBwRts
    );

VOID
txmFillPktOptionByDesc(
    P_MSDU_INFO_T prMsduInfo,
    P_HW_MAC_TX_DESC_T prTxDesc
    );

VOID
txmFillDescByPktOption(
    P_MSDU_INFO_T prMsduInfo,
    P_HW_MAC_TX_DESC_T prTxDesc
    );

VOID
txmAssignPID(
    IN P_MSDU_INFO_T prMsduInfo,
    IN UINT_8 ucWlanIdx
    );

P_MSDU_INFO_T
txmGetTxingMsduInfo(
    IN UINT_8 ucTargetPID,
    IN UINT_8 ucWlanIdx
    );

UINT_16
txmGetPktFrameCtrlForTxDone(
    P_MSDU_INFO_T prMsduInfo
    );

UINT_16
txmGetPktQosCtrlForTxDone(
    P_MSDU_INFO_T prMsduInfo
    );

UINT_16
txmGetPktSeqNumForTxDone(
    P_MSDU_INFO_T prMsduInfo
    );

UINT_32
txmGetDescRemainingLifeTimeInMs(
    P_HW_MAC_TX_DESC_T prTxDesc
    );

VOID
txmSetDescRemainingLifeTimeInMs(
    P_HW_MAC_TX_DESC_T prTxDesc,
    UINT_32 u4LifeTimeInMs
    );

#if 0 //IOT_PROCESS_PORTING
VOID
txmSetDefaultRate(
    P_RA_ENTRY_INFO_T prRaEntry,
    UINT_8 ucStaRecIdx
    );
#endif/*IOT_PROCESS_PORTING*/
UINT_16
txmGetDefaultRate(
    P_STA_RECORD_T prStaRec
    );


#if (CFG_AP_PWS_SUPPORT == 1)
WLAN_STATUS
txmCmdApPsStatusClear(
    IN P_MSDU_INFO_T prMsduInfo
    );

WLAN_STATUS
txmCmdApPsStart(
    IN P_MSDU_INFO_T prMsduInfo
    );

WLAN_STATUS
txmCmdApPsCapability(
    IN P_MSDU_INFO_T prMsduInfo
    );
#endif

#endif  //#ifndef _TXM_H_

